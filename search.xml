<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/18/hello-world/</url>
    <content><![CDATA[<p>this is my frist program  </p>
<h2 id="Welcome-！"><a href="#Welcome-！" class="headerlink" title="Welcome ！"></a>Welcome ！</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>software</title>
    <url>/2023/03/14/software/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="1、什么是软件工程-目前有哪几种主要的软件工程方法"><a href="#1、什么是软件工程-目前有哪几种主要的软件工程方法" class="headerlink" title="1、什么是软件工程?目前有哪几种主要的软件工程方法?"></a>1、什么是软件工程?目前有哪几种主要的软件工程方法?</h3><p>概括地说,软件工程是指导计算机软件开发和维护的一门工程学科.采用工程的概念、原理、技术、和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
<p>主要有传统方法也称为经典软件工程方法或生命周期方法或结构化范型和面向对象方法。</p>
<h3 id="2、软件的生命周期"><a href="#2、软件的生命周期" class="headerlink" title="2、软件的生命周期"></a>2、软件的生命周期</h3><p>软件生命周期又称为软件生存周期或系统开发生命周期，是软件的产生直到报废的生命周期。软件生存周期包括：</p>
<blockquote>
<p>（1）问题定义：弄清”用户需要计算机解决什么样的问题”，提出”系统目标和范围的说明“，提交用户审查和确认。</p>
<p>（2）可行性分析：把待开发系统的目标以明确的语言描述出来，并从经济、技术、法律等多个方面进行可行性分析。</p>
<p>（3）需求分析：弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。</p>
<p>（4）开发阶段：设计、实现（完成源程序的编码）、测试</p>
<p>（5）维护：改正性维护（由于开发测试的不彻底、不完全），适应性维护（适应环境变化），完善性维护（使用过程中提出的一些建设性意见），预防性维护（改善软件系统的可维护性和可靠性）。</p>
</blockquote>
<h3 id="3、软件过程"><a href="#3、软件过程" class="headerlink" title="3、软件过程"></a>3、软件过程</h3><p>软件生命周期所涉及的一系列相关过程，是指一套关于项目的阶段、状态、方法、技术和开发、维护软件的人员以及相关Artifacts（计划、文档、模型、编码、测试、手册等）组成。包含基本过程类、支持过程类、组织过程类。</p>
<blockquote>
<p>（1）基本过程类包括获取过程、供应过程、开发过程、运作过程、维护过程和管理过程。</p>
<p>（2）支持过程类包括文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程以及问题解决过程。</p>
<p>（3）组织过程类包括基础设施过程、改进过程、培训过程。</p>
</blockquote>
<h3 id="4、软件需求分析的任务是什么？有哪些主要步骤？"><a href="#4、软件需求分析的任务是什么？有哪些主要步骤？" class="headerlink" title="4、软件需求分析的任务是什么？有哪些主要步骤？"></a>4、软件需求分析的任务是什么？有哪些主要步骤？</h3><p>需求分析的基本任务是深入描述软件的功能和性能、确定软件设计的约束和软件同其它系统元素的接口细节、定义软件的其它有效性需求，总之，需求分析的任务就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题。</p>
<p>主要步骤：</p>
<h4 id="问题识别"><a href="#问题识别" class="headerlink" title=".问题识别"></a>.问题识别</h4><blockquote>
<p>(1)功能需求：明确所开发的软件必须具备什么样的功能。</p>
<p>(2)性能需求：明确待开发的软件的技术性能指标。</p>
<p>(3)环境需求：明确软件运行时所需要的软、硬件的要求。</p>
<p>(4)用户界面需求：明确人机交互方式、输入输出数据格式。</p>
</blockquote>
<h4 id="分析与综合，导出软件的逻辑模型"><a href="#分析与综合，导出软件的逻辑模型" class="headerlink" title="分析与综合，导出软件的逻辑模型"></a>分析与综合，导出软件的逻辑模型</h4><p>分析人员对获取的需求，进行一致性的分析检查，在分析、综合中逐步细化软件功能，划分成各个子功能。用图文结合的形式，建立起新系统的逻辑模型。</p>
<h4 id="编写文档"><a href="#编写文档" class="headerlink" title=".编写文档"></a>.编写文档</h4><blockquote>
<p>(1)编写“需求规格说明书”，把双方共同的理解与分析结果用规范的方式描述出来，作为今后各项工作的基础。</p>
<p>(2)编写初步用户使用手册，着重反映被开发软件的用户功能界面和用户使用的具体要求，用户手册能强制分析人员从用户使用的观点考虑软件。</p>
<p>(3)编写确认测试计划，作为今后确认和验收的依据。</p>
<p>(4)修改完善软件开发计划。在需求分析阶段对待开发的系统有了更进一步的了解，所以能更准确地估计开发成本、进度及资源要求，因此对原计划要进行适当修正。</p>
</blockquote>
<h3 id="5、软件工程模型"><a href="#5、软件工程模型" class="headerlink" title="5、软件工程模型"></a>5、软件工程模型</h3><p>常见软件工程模型如下：</p>
<h5 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h5><p>将软件生命周期中的各个活动规定为线性连接的模型，包括需求分析、设计、编码、测试、运行与维护，由前至后、相互衔接的固定顺序，如同瀑布流水逐级下落。</p>
<p>瀑布模型是以文档作为驱动、适合于软件需求很明确的软件项目的模型。</p>
<h5 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h5><p>瀑布模型的一个变体，提供了一种验证确认活动应用于早期软件工程工作中的方法。</p>
<p>瀑布模型的优点：1）容易理解，管理成本低；2）强调开发的阶段性早期计划及需求调查和产品测试。</p>
<p>瀑布模型的缺点：1）客户必须能够完整、正确和清晰地表达他们的需要；2）开始2个或3个阶段，很难评估真正的进度；3）项目结束时，出现大量的集成和测试工作；4）需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。</p>
<h5 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h5><p>融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。</p>
<p>使用增量模型，第1个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每一个增量均发布一个可操作的产品。</p>
<p>增量模型的优点：1）容易理解，管理成本低；2）强调开发的阶段性早期计划及需求调查和产品测试；3）第一个可交付版本所需要的成本和时间很少；4）开发由增量表示的小系统所承担的风险不大；5）减少用户需求的变更；6）运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</p>
<p>增量模型的缺点：1）如果没有对用户的变更需求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；2）如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；３）管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</p>
<h5 id="演化模型："><a href="#演化模型：" class="headerlink" title="演化模型："></a>演化模型：</h5><p>是迭代的过程，软件开发人员能逐步开发出更完整的软件版本，适用于软件需求缺乏准确认识的情况，典型的演化模型有原型模型和螺旋模型。</p>
<p>４．１）演化模型之原型模型：是预期系统的一个可执行版本，反映了系统性的一个选定的子集，一个原型不必满足目标软件的所有约束，目的是能快速、低成本地构建原型。</p>
<p>原型模型开始于沟通，其目的是定义软件的总体目标，标识需求，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速射击的方式对其进行建模，并构建原型。</p>
<p>根据原型的目的，可分为三种：１）探索型原型：目的是弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性；２）实验型原型：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等；３）演化型原型：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。</p>
<p>４．２）演化型模型之螺旋模型：将瀑布模型与演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：</p>
<p>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型特别适用于庞大、复杂并且具有高风险的系统。</p>
<h5 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h5><p>一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性，喷泉模型使开发过程具有迭代性和无间隙性。</p>
<p>优点：提高软件项目的开发效率，节省开发时间。</p>
<p>缺点：开发阶段是重叠的，开发过程中需要大量的开发人员，不利于项目的管理。需要严格的管理文档，使得审核的难度加大。</p>
<h3 id="6、简述结构化分析、设计的要点："><a href="#6、简述结构化分析、设计的要点：" class="headerlink" title="6、简述结构化分析、设计的要点："></a>6、简述结构化分析、设计的要点：</h3><p>结构化分析方法适合于数据处理类型软件的需求分析。 其要点是”自顶向下”地开发系统,由整体到各组成部分,由表及里,由抽象到具体,逐步求精.</p>
<p>(1) 模块化 (2)由顶向下,逐步求精.(3)上层模块分解为下层模块,有三种不同的结构形式,即顺序结构,选择结构和循环结构.</p>
<h3 id="7、软件测试的目标是什么，有哪几种主要有测试方法？-软件测试的目标："><a href="#7、软件测试的目标是什么，有哪几种主要有测试方法？-软件测试的目标：" class="headerlink" title="7、软件测试的目标是什么，有哪几种主要有测试方法？ 软件测试的目标："></a>7、软件测试的目标是什么，有哪几种主要有测试方法？ 软件测试的目标：</h3><blockquote>
<p>(1)测试是为了发现程序中的错误而执行程序的过程；</p>
<p>(2)好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案；</p>
<p>(3)成功的测试是发现了至今为止尚未发现的错误的测试。</p>
</blockquote>
<p>软件测试的方法有动态测试、静态测试和正确性证明。</p>
<p>a.黑盒测试： 黑盒测试是将被测软件看出一个黑盒子，只考虑系统的输入和输出，完全不考虑程序内部的逻辑结构和处理过程。 黑盒测试的依据是开发各阶段的需求规格说明。</p>
<p>b.白盒测试：白盒测试是将黑盒子打开，研究源代码和程序内部的逻辑结构；</p>
<h3 id="8、白盒测试主要有哪些覆盖？"><a href="#8、白盒测试主要有哪些覆盖？" class="headerlink" title="8、白盒测试主要有哪些覆盖？"></a>8、白盒测试主要有哪些覆盖？</h3><p>语句覆盖、判定覆盖、 条件覆盖、判定/条件覆盖、条件组合覆盖、 点覆盖、 边覆盖、路径覆盖</p>
<h3 id="9、选择一种程序设计语言的主要有哪些依据？"><a href="#9、选择一种程序设计语言的主要有哪些依据？" class="headerlink" title="9、选择一种程序设计语言的主要有哪些依据？"></a>9、选择一种程序设计语言的主要有哪些依据？</h3><p>为了使程序容易测试和维护以减少生命周期的总成本，选用的高级语言应该有理想的模块化机制，以及可读性好的控制结构和数据结构；</p>
<p>为了便于调试和提高软件可靠性，语言特点应该使编译程序能够尽可能多地发现程序中的错误；</p>
<p>为了降低软件开发和维护的成本，选用的语言应该有良好的独立编译机制。</p>
<p>上述这些要求是选择语言的理想标准，但是在实际选用语言时不能仅仅考虑理论上的标准，还必须同时考虑实用方面的各种限制。 (1)系统用户的要求 (2)可以使用的编译程序 (3)可以得到的软件工具 (4)系统规模 (5)程序员的知识 (6)软件可移植性要求 (7)软件的应用领域</p>
<h3 id="10、软件的维护的目标是什么，有哪几种维护类型？"><a href="#10、软件的维护的目标是什么，有哪几种维护类型？" class="headerlink" title="10、软件的维护的目标是什么，有哪几种维护类型？"></a>10、软件的维护的目标是什么，有哪几种维护类型？</h3><p>纠正在使用过程中暴露出来的错误而进行的改进性维护，适应外部环境的变化而进行的适应性维护，改进原有的软件而进行的完善性维护，以及改进将来的可维护性和可靠性而进行的预防性维护。 软件维护的分类： 软件维护主要划分为纠错性维护、适应性维护和完善性维护。</p>
<p>(1)纠错性维护。由于前期的测试不可能揭露软件系统中所有潜在的错误，用户在使用软件时仍将会遇到错误，诊断和改正这些错误的过程称为纠错性维护。</p>
<p>(2)适应性维护。由于新的硬件设备不断推出，操作系统和编译系统也不断地升级，为了使软件能适应新的环境而引起的程序修改和扩充活动称为适应性维护。</p>
<p>(3)完善性维护。在软件的正常使用过程中，用户还会不断地提出新的需求。为了满足用户新的需求而增加软件功能的活动称为完善性维护。</p>
<h3 id="11、简述提高软件质量的主要措施。"><a href="#11、简述提高软件质量的主要措施。" class="headerlink" title="11、简述提高软件质量的主要措施。"></a>11、简述提高软件质量的主要措施。</h3><p>复审：是在软件生命周期每个阶段结束之前，都采用一定的标准对该段产生的软件配置成分进行严格的正式或非正式的检测。</p>
<p>复查：是检查已有的材料，以断定在软件生命周期某个阶段的工作是否能够开始或继续。</p>
<p>管理复审：是向开发组织或使用部门的管理人员提供有关项目的总体状况、成本和进度等方面的情况，以便他们从管理角度对开发工作进行审查。</p>
<p>测试：包括测试计划、测试过程和测试结果3个阶段。</p>
<h3 id="12、面向对象如何实现模块独立性，其耦合和内聚的含义是什么？"><a href="#12、面向对象如何实现模块独立性，其耦合和内聚的含义是什么？" class="headerlink" title="12、面向对象如何实现模块独立性，其耦合和内聚的含义是什么？"></a>12、面向对象如何实现模块独立性，其耦合和内聚的含义是什么？</h3><p>因为对象是由数据及可以对这些数据施加的操作所组成的统一体，而且对象是以数据为中心的，操作围绕对其数据所需做的处理来设置，没有无关的操作。因此，对象内部各种元素彼此结合得很紧密。内聚性相当强，由于完成对象所需要的元素（数据和方法）基本上都被封装在对象内部，它与外界的联系自然就比较少。因此，对象之间的耦合通常比较松。总之，面向对象使用对象、类、继承和消息的方法，既使用类和继承等机制，而且对象之间仅能通过传递消息实现彼此通信来实现模块的独立性。</p>
<h3 id="13、面向对象和面向过程软件工程有哪些区别？"><a href="#13、面向对象和面向过程软件工程有哪些区别？" class="headerlink" title="13、面向对象和面向过程软件工程有哪些区别？"></a>13、面向对象和面向过程软件工程有哪些区别？</h3><blockquote>
<p>（1）面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>（2）面向过程是把一件事一项工程分解成为一个个小的功能,用一个个函数来实现；面向对象是把事情看成是一个个小的对象组成的,或者说一个个小部分组成的,这些对象之间的相互关系,构成了整个项目.在面向对象的思想中，万物皆对象。而”类”，就是对象的抽象或者说是概括。</p>
</blockquote>
<h3 id="14、简述对象、类、消息、方法的基本概念。"><a href="#14、简述对象、类、消息、方法的基本概念。" class="headerlink" title="14、简述对象、类、消息、方法的基本概念。"></a>14、简述对象、类、消息、方法的基本概念。</h3><blockquote>
<p>（1)对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。</p>
<p>（2）类是具有相同或相似性质的对象的抽象。对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象。类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性。 类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。</p>
<p>​    (3)对象之间进行通信的结构叫做消息。在对象的操作中，当一个消息发送给某个对象时，消息包含接收对象去执行某种操作的信息。发送一条消息至少要包括说明接受消息的对象名、发送给该对象的消息名（即对象名、方法名）。一般还要对参数加以说明，参数可以是认识该消息的对象所知道的变量名，或者是所有对象都知道的全局变量名。</p>
<p>（4）类中操作的实现过程叫做方法，一个方法有方法名、参数、方法体。</p>
</blockquote>
<h3 id="15、简述面向对象分析设计的三个模型。"><a href="#15、简述面向对象分析设计的三个模型。" class="headerlink" title="15、简述面向对象分析设计的三个模型。"></a>15、简述面向对象分析设计的三个模型。</h3><p>答：三个模型：对象模型、动态模型、功能模型</p>
<blockquote>
<p>（1）对象模型描述系统的静态结构，包括类和对象，它们的属性和操作，以及它们之间的关系。构造对象模型的目的在于找出与应用程序密切相关的概念。对象模型用包含对象及对象的关系图表示。</p>
<p>（2）动态模型着重于系统的控制逻辑，考察在任何时候对象及其关系的改变，描述这些涉及时序和改变的状态。动态模型包括状态图和事件跟踪图。状态图是一个状态和事件的网络，侧重于描述每一类对象的动态行为。事件跟踪图则侧重于说明系统执行过程中的一个特点“场景”，也叫做脚本(scenarios)，是完成系统某个功能的一个事件序列。脚本通常起始于一个系统外部的输入事件，结束于一个系统外部的输出事件。</p>
<p>（3）功能模型着重于系统内部数据的传送和处理。功能模型表明，通过计算，从输出数据能得到什么样的输出数据，但不考虑参加计算的数据按什么时序执行。功能模型由多个数据流图组成，它们指明从外部输出，通过操作和内部存储，直到外部输出的整个数据流情况。功能模型还包括了对象模型内部数据间的限制。功能模型中的数据流图往往形成一个层次结构，一个数据流图的过程可以由下一层的数据流图作进一步的说明。</p>
</blockquote>
<h3 id="16、UML-里面有哪些图？"><a href="#16、UML-里面有哪些图？" class="headerlink" title="16、UML 里面有哪些图？"></a>16、UML 里面有哪些图？</h3><p>UML 图包括九种：使用案例图、类图、对象图、构件图、部署图、活动图、协作图、状态图、序列图。在这些图中使用案例图、类图、序列图是最有用的。<br>1、需求<br>采用用例图描述需求。<br>2、 分析<br>采用类图描述静态结构<br>采用顺序图、合作图、活动图、状态图描述动态行为<br>3、设计<br>采用类图、包，对类的接口进行设计<br>4、 实现<br>将类用某现象对象语言实现<br>5、继承与交付<br>构件图、包、部署图<br>6、 测试<br>单元测试——类图和类的说明书</p>
<h3 id="17、-软件系统的三个测试阶段"><a href="#17、-软件系统的三个测试阶段" class="headerlink" title="17、 软件系统的三个测试阶段"></a>17、 软件系统的三个测试阶段</h3><blockquote>
<p>开发测试：在开发过程中对系统进行测试以发现bug和缺陷。</p>
<p>发布测试： 在系统发布给用户之前，单独的测试团队测试系统的完整版本。</p>
<p>用户测试 ： 其中系统的用户或潜在用户在自己的环境中测试系统。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>bochs</title>
    <url>/2022/03/25/bochs/</url>
    <content><![CDATA[<h1 id="BOCHS虚拟端口号"><a href="#BOCHS虚拟端口号" class="headerlink" title="BOCHS虚拟端口号"></a>BOCHS虚拟端口号</h1><span id="more"></span>

<h2 id="主要端口号"><a href="#主要端口号" class="headerlink" title="主要端口号"></a>主要端口号</h2><table>
<thead>
<tr>
<th align="center">0000-001f</th>
<th align="center">dma1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0020-0021</td>
<td align="center">pic1</td>
</tr>
<tr>
<td align="center">0040-0043</td>
<td align="center">timer0</td>
</tr>
<tr>
<td align="center">0050-0053</td>
<td align="center">timer1</td>
</tr>
<tr>
<td align="center">0060-0060</td>
<td align="center">keyboard</td>
</tr>
<tr>
<td align="center">0064-0064</td>
<td align="center">keyboard</td>
</tr>
<tr>
<td align="center">0070-0077</td>
<td align="center">rtc</td>
</tr>
<tr>
<td align="center">0080-008f</td>
<td align="center">dma page reg</td>
</tr>
<tr>
<td align="center">00a0-00a1</td>
<td align="center">pic2</td>
</tr>
<tr>
<td align="center">00c0-00df</td>
<td align="center">dma2</td>
</tr>
<tr>
<td align="center">00f0-00ff</td>
<td align="center">fpu</td>
</tr>
<tr>
<td align="center">0170-0177</td>
<td align="center">ide1</td>
</tr>
<tr>
<td align="center">02f8-02ff</td>
<td align="center">serial</td>
</tr>
<tr>
<td align="center">0376-0376</td>
<td align="center">ide1</td>
</tr>
<tr>
<td align="center">0378-037a</td>
<td align="center">parport0</td>
</tr>
<tr>
<td align="center">03c0-03df</td>
<td align="center">vga+</td>
</tr>
<tr>
<td align="center">03f2-03f5</td>
<td align="center">floppy</td>
</tr>
<tr>
<td align="center">03f7-03f7</td>
<td align="center">floppy DIR</td>
</tr>
<tr>
<td align="center">03f8-03ff</td>
<td align="center">serial</td>
</tr>
<tr>
<td align="center">03f8-03ff</td>
<td align="center">serial</td>
</tr>
<tr>
<td align="center">1000-103f</td>
<td align="center">0000:00:07.3</td>
</tr>
<tr>
<td align="center">1000-103f</td>
<td align="center">motherboard</td>
</tr>
<tr>
<td align="center">1000-1003</td>
<td align="center">ACPI PM1a_EVT_BLK</td>
</tr>
<tr>
<td align="center">1004-1005</td>
<td align="center">ACPI PM1a_CNT_BLK</td>
</tr>
<tr>
<td align="center">1008-100b</td>
<td align="center">ACPI PM_TMR</td>
</tr>
<tr>
<td align="center">100c-100f</td>
<td align="center">ACPI GPE0_BLK</td>
</tr>
<tr>
<td align="center">1010-1015</td>
<td align="center">ACPI CPU throttle</td>
</tr>
<tr>
<td align="center">1040-104f</td>
<td align="center">0000:00:07.3</td>
</tr>
<tr>
<td align="center">1040-104f</td>
<td align="center">motherboard</td>
</tr>
<tr>
<td align="center">1060-107f</td>
<td align="center">pnp 00:0d</td>
</tr>
<tr>
<td align="center">1080-10bf</td>
<td align="center">0000:00:077</td>
</tr>
<tr>
<td align="center">10c0-10cf</td>
<td align="center">0000:00:07.1</td>
</tr>
<tr>
<td align="center">10c0-10c7</td>
<td align="center">ide0</td>
</tr>
<tr>
<td align="center">10c8-10cf</td>
<td align="center">ide1</td>
</tr>
<tr>
<td align="center">10d0-10df</td>
<td align="center">0000:00:0f.0</td>
</tr>
<tr>
<td align="center">1400-14ff</td>
<td align="center">0000:00:10.0</td>
</tr>
<tr>
<td align="center">2000-3fff</td>
<td align="center">PCI Bus #02</td>
</tr>
<tr>
<td align="center">2000-207f</td>
<td align="center">0000:02:00.0</td>
</tr>
<tr>
<td align="center">2000-201f</td>
<td align="center">pcnet32_probe_pci</td>
</tr>
<tr>
<td align="center">4000-4fff</td>
<td align="center">PCI Bus #03</td>
</tr>
<tr>
<td align="center">5000-5fff</td>
<td align="center">PCI Bus #0b</td>
</tr>
<tr>
<td align="center">6000-6fff</td>
<td align="center">PCI Bus #13</td>
</tr>
<tr>
<td align="center">7000-7fff</td>
<td align="center">PCI Bus #1b</td>
</tr>
<tr>
<td align="center">8000-8fff</td>
<td align="center">PCI Bus #04</td>
</tr>
<tr>
<td align="center">9000-9fff</td>
<td align="center">PCI Bus #0c</td>
</tr>
<tr>
<td align="center">a000-afff</td>
<td align="center">PCI Bus #14</td>
</tr>
<tr>
<td align="center">b000-bfff</td>
<td align="center">PCI Bus #1c</td>
</tr>
<tr>
<td align="center">c000-cfff</td>
<td align="center">PCI Bus #05</td>
</tr>
<tr>
<td align="center">d000-dfff</td>
<td align="center">PCI Bus #0d</td>
</tr>
<tr>
<td align="center">e000-efff</td>
<td align="center">PCI Bus #15</td>
</tr>
<tr>
<td align="center">f000-ffff</td>
<td align="center">PCI Bus #1d</td>
</tr>
</tbody></table>
<h2 id="I-O-Ports-and-Controllers-on-IBM-Compatibles-and-PS-2"><a href="#I-O-Ports-and-Controllers-on-IBM-Compatibles-and-PS-2" class="headerlink" title="I/O Ports and Controllers on IBM Compatibles and PS/2"></a>I/O Ports and Controllers on IBM Compatibles and PS/2</h2><p>The following gives the input and output ports used by IBM PC compatible computers.  Most ports allow access to input and output device controllers.  A controller may have several internal registers which can be set to fix the operation of that controller, read its status, or send data to it.  Other ports access discrete logic latches or registers.</p>
<p>Some ports are write-only or read-only.  It is even possible for a port to be write-only and read-only by using two different registers at the same port address.  Port addresses can range from 0 to 0FFFFH (64K ports). However, PC system boards generally reserve only the first 1024 (0-3FFH). The AT and PS/2 freely employ ports above 3FFH for extended applications, such as the two port asynchronous adaptors and network adaptors.</p>
<p>Ports from 0-0FFH have a special significance, since the 80x86 can use byte rather than word port addresses in the IN and OUT instructions.</p>
<h3 id="Port-Function-and-Chip-Server-if-present"><a href="#Port-Function-and-Chip-Server-if-present" class="headerlink" title="Port    Function and Chip Server (if present)"></a>Port    Function and Chip Server (if present)</h3><p> 000-00F  DMA Direct Memory Access Processor 8237A-5 or equivalent<br> 010-01F  Extended DMA on PS/2 60-80<br> 020-021  Interrupt Generation 8259A Master Interrupt Processor<br> 030-03F  AT 8259 Master Interrupt Controller extended ports<br>   040    System Timer 8253  Count Reg, Channel 0 System timer<br>   042    Count Reg, Channel 2 Speaker audio<br>   043    Control byte for channels 0 or 2<br>   044    Extended Timer for PS/2 Count Reg, Channel 3 Watchdog timer<br>   047    Control byte for channel 3<br> 050-05F  AT 8254 Timer<br> 060-063  PPI Status Port PPI 8255 Keyboard, PC read switches SW1, SW2<br>   064    Extended PPI PS/2 8042 Keyboard, Aux. Device Controller<br> 070-071  AT and PS/2 CMOS ports RTC/CMOS MC146818 Clock and PS/2 NMI mask<br> 081-083  DMA Controller Registers 0-2<br>   087    DMA Controller Register 3<br> 089-08B  DMA Controller Registers 4-6<br>   08F    DMA Controller Register 7<br>   090    Central Arbitration Control Port PS/2<br>   091    Card Selection Feedback PS/2<br>   092    System Control Port A on PS/2: Control and Status Register<br>   094    Video System Setup on PS/2: Programmable Option Select (POS) Setup<br>   095    PS/2 Reserved<br>   096    POS Channel Select on PS/2: Program Option Select Adapter<br>   0A0    PC NMI Mask Register on PC: Discrete latch for masking the NMI<br> 0A0-0A1  Slave Interrupts on AT, PS/2 8259A Slave Interrupt Controller<br> 0B0-0BF  AT 8259 Slave Interrupt Controller extended ports<br> 0C0-0DF  DMA Controller on PS/2 or Sound Generator on PCjr (0C0 port)<br> 0E0-0EF  AT reserved<br> 0F0-0FF  Math Coprocessor 80x87 on PS/2 or PCjr diskette controller<br> 100-107  Program Option Select on PS/2: POS Registers<br> 110-1EF  AT I/O options<br> 1F0-1F8  AT Fixed Disk Controller<br> 200-20F  Game I/O Ports, discrete logic (Active port: 201H)<br> 210-217  PC Expansion Unit<br>   21F    AT reserved<br> 248-24F  Serial #8 option 8250 ACE<br> 268-26F  Serial #6 option 8250 ACE<br> 278-27F  Parallel Port LPT3: discrete logic<br> 2A2-2A3  Clock option: MSM58321RS Clock Chip<br> 2B0-2DF  Alternate EGA on PC and AT<br>   2E1    AT GPIB Adapter 0<br> 2E2-2E3  AT Data Acquisition adapter 0</p>
<p> 2E8-2EF  Serial Port COM4: on PC 8250 ACE used with IRQ3<br> 2F8-2FF  Serial Port COM2: on PC and PS/2 ACE used with IRQ3<br> 300-31F  PC Prototype card on PC<br> 320-32F  XT Fixed disk Controller<br> 348-34F  Serial #7 option 8250 ACE<br> 368-36F  Serial #5 option 8250 ACE<br> 378-37F  Parallel Port LPT2: discrete logic parallel port<br> 380-38C  SBSI on PC, AT Secondary Binary Synchronous Interface<br> 3A0-3A9  PBSI on PC, AT Primary Binary Synchronous Interface<br>   3B4    Monochrome Index Reg.   6845 Video Controller CRT Index Register<br>   3B5    Monochrome Control Regs.6845 Video CRT Control Registers<br>   3B8    Mono. Control Port      6845 CRT Control Port<br>   3BA    Mono. Status/Feature    Input Status/Output Feature Control Reg.<br> 3BC-3BE  Parallel Port LPT1: discrete logic parallel port using IRQ7<br> 3C0-3C5  Video Subsystem         VGA Attribute and Sequencer Registers<br> 3C6-3C8  Video DAC               VGA Digital-to-Analog Converter<br> 3CE-3CF  Video Subsystem         VGA Graphics Registers<br>   3D4    PC Color Graphics       6845 Video Controller CRT Index Register<br>   3D5    PC Color Graphics       6845 Video CRT Control Registers<br>   3DA    PC Color Status/Feature Input Status/Output Feature Control Reg.<br> 3E8-3EF  Serial Port COM3:on PC 8250 ACE used with IRQ3<br> 3F0-3F7  Diskette Controller 765 Chip<br> 3F8-3FF  Serial Port COM1: on  PC and PS/2 ACE used with IRQ4<br> 6E2-6E3  AT Data Acquisition Adapter 1<br> 790-793  Cluster Adapter 1<br> AE2-AE3  AT Data Acquisition Adapter 2<br> B90-B93  Cluster Adapter 2<br> EE2-EE3  AT Data Acquisition Adapter 3<br> B90-B93  Cluster Adapter 3<br>  22E1    AT GPIB Adapter 1<br>2390-2393 Cluster Adapter 4<br>  42E1    AT GPIB Adapter 2<br>  3220    Serial Port COM3:   PS/2 Asychronous Adaptor<br>  3228    Serial Port COM4:   PS/2 Asychronous Adaptor<br>  4220    Serial Port COM5:   PS/2 Asychronous Adaptor<br>  4228    Serial Port COM6:   PS/2 Asychronous Adaptor<br>  42E1    AT GPIB Adapter 2<br>  5220    Serial Port COM7:   PS/2 Asychronous Adaptor<br>  5228    Serial Port COM8:   PS/2 Asychronous Adaptor<br>  62E1    AT GPIB Adapter 3<br>  82E1    AT GPIB Adapter 4<br>  A2E1    AT GPIB Adapter 5<br>  C2E1    AT GPIB Adapter 6<br>  E2E1    AT GPIB Adapter 7</p>
<h3 id="Ports-00-0FH-and-81H-83H-The-8237A-DMA-Controller-Chip-and-PS-2-Extensions"><a href="#Ports-00-0FH-and-81H-83H-The-8237A-DMA-Controller-Chip-and-PS-2-Extensions" class="headerlink" title="Ports 00-0FH and 81H-83H: The 8237A DMA Controller Chip and PS/2 Extensions"></a>Ports 00-0FH and 81H-83H: The 8237A DMA Controller Chip and PS/2 Extensions</h3><p>The 8237A chip controls direct memory access (DMA) to and from a set of<br>16 ports from 000H to 00FH.  There are three DMA channels available. DMA<br>is performed by stealing a CPU bus cycle, setting a wait state if<br>necessary, to transfer each byte.  Ports 081H to 083H are DMA page<br>register ports for DMA channel 1-3.  Amoung the 20 bits for memory<br>addressing during DMA transfer, the first four bits are the output of<br>the page register.  The last 16 bits are output from the 8237A.</p>
<p>On an IBM PC compatible, channel 0 is used by the hardware to refresh<br>dynamic RAM.  This channel is not available to software.</p>
<h3 id="Ports-20H-21H-Master-8259A-Interrupt-Controller"><a href="#Ports-20H-21H-Master-8259A-Interrupt-Controller" class="headerlink" title="Ports 20H-21H: Master 8259A Interrupt Controller"></a>Ports 20H-21H: Master 8259A Interrupt Controller</h3><p>The first 8259A occupies two port addresses at 020H-021H from which four<br>initialization command word registers and three operation command word<br>registers are set. Three interrupt status registers can be read.<br>The 8259A can be used to generate INTR 80x86 type interrupts from a<br>hardware device.  Moreover, several 8259As can be chained together.  The<br>ATs and PS/2s use a second slave 8259A.</p>
<p>The 8259A has three one-byte registers to control and monitor eight<br>hardware interrupt lines IRx.  A bit in the interrupt-request-register<br>(IRR) is set when an interrupt request line becomes active.  The<br>in-service-register (ISR) is checked to see if another interrupt is in<br>progress.  Also, the priority of the interrupts is checked.  Then, the<br>interrupt-mask-register (IMR) is used to verify if the interrupt is<br>allowed.  The IMR can be programmed to mask interrupts by setting the<br>corresponding bits and sending the byte to the second controller port.<br>After a hardware interrupt service routine is finished, the controller<br>interrupts must be re-enabled by sending 20H to the first controller<br>port.</p>
<p>   On IBM PC machines, the 8259A is set to respond to positive-going<br>edges on the interrupt request lines (IRQ0-IRQ7), to use interrupt<br>vectors 08-0FH, to use buffered mode, and to re-initialize interrupts<br>upon receipt of 020H (end-of-interrupt) code on port 20H.  Configuration<br>can be performed using:</p>
<p>   MOV AL,13H      ; edge-triggered, one 8259a, icw4 needed<br>   OUT 20H,AL<br>   MOV AL,8        ; use interrupt vectors 08-0fh for IR0-IR7<br>   OUT 21H,AL<br>   MOV AL,9        ; icw4 buffered mode, normal eoi, 8086 CPU<br>   OUT 21H,AL</p>
<p>To enable BIOS interrupt routines, use mask 0bch (0 bit means enable):</p>
<p>   MOV AL,0BCH     ; enable disk (bit 6), keyboard (bit 1), timer (bit 0)<br>   OUT 21H,AL<br>   STI</p>
<p>   MOV AL,20H      ; eoi command<br>   OUT 20H,AL</p>
<p>The IRQn lines are set to CPU interrupt service by the master and slave<br>interrupt controllers in the following order:</p>
<p>Hardware Interrupts                          Software Service Routine</p>
<p>  IRQ0 Timer every 0.054897095 seconds          INT  8H<br>  IRQ1 Keyboard interrupt service               INT  9H<br>  IRQ2 I/O channel, slave 8259, vga             INT 0AH<br>      IRQ8  Real Time Clock                           INT 70H<br>      IRQ9  Replace IRQ2 and LAN Adapter interrupt    INT 71H<br>      IRQ10 Reserved                                  INT 72H<br>      IRQ11 Reserved                                  INT 73H<br>      IRQ12 Mouse interrupt                           INT 74H<br>      IRQ13 Math coprocessor                          INT 75H<br>      IRQ14 Fixed disk controller                     INT 76H<br>      IRQ15 Reserved                                  INT 77H<br>  IRQ3 Serial device COM2                         INT 0BH<br>  IRQ4 Serial device COM1                         INT 0CH<br>  IRQ5 Hard drive int.(also LPT2 on AT)           INT 0DH<br>  IRQ6 Diskette drive interrupt                   INT 0EH<br>  IRQ7 Parallel port device LPT1                  INT 0FH</p>
<p>General programming considerations:</p>
<p>General initialization sequence (* for IBM PC):</p>
<ol>
<li>Send initialization command “word” (ICW1) to port 20H as byte:</li>
</ol>
<p>   bit     description</p>
<p>   7-5     A7-A5 vector address table for 8080 or 8085 sytem<br>         * 000 if 8086 system<br>    4    * 1  ICW1 identifier bit<br>    3    * 0= edge sensitive interrupt<br>           1= level sensitive interrupt<br>    2      0= eight byte vector addresses in interrupt table<br>         * 1= four byte vector addresses in interrupt table (IBM)<br>    1      0= Several 8259A chips in system (cascade mode, ICW3 needed)<br>         * 1= only one 8259A chip in system (no slaves, no ICW3 needed)<br>    0      0= ICW4 not needed<br>         * 1= ICW4 to be sent</p>
<ol start="2">
<li>Send ICW2 to port 21H as byte:</li>
</ol>
<pre><code>bit    description


 7-3   A15-A11 if 8080/85 system,
     * A7-A3 vector address if 8086 system
 0-2   A10-A8 if 8080/85 system
     * 000 if 8086 system
</code></pre>
<ol start="3">
<li>If ICW1 bit 1=0, send ICW3 to 21H as mask to show which IRn lines have<br>slave 8259As.  If this 8259A is a slave, use bits 0-3 to set value<br>of master IRn to which this slave is attached.</li>
</ol>
<ol start="4">
<li>Send ICW4 to port 21H as byte:</li>
</ol>
<pre><code>bit    description


7-5    not used, set 0
 4   * 0= serve interrupts sequentially
       1= priority nested order: IR0 &gt; IR1 &gt; ... IR7
 3     0= non-buffered mode, ignore bit 2
     * 1= buffered mode selected, check bit 2 and use SP/EN line
 2   * 0= slave if bit 3=1
       1= master controller if bit 3=1
 1   * 0= not automatic end-of-interrupt (must send eoi=20h to 21h)
       1= automatic end-of-interrupt
 0     0=8080/8085 mode
     * 1=8086 mode
</code></pre>
<p>Commands:  The following operation command “words” can be sent to the<br>8259A (in any order, as needed), by out commands to port 20H and 21H:</p>
<p>Operation Command “Word” 1: Mask for IR0-IR7 (reset bit to 0 to enable<br>interrupt); send to 21H.</p>
<p>Operation Command “Word” 2 to port 20H:</p>
<pre><code>bit    description

 7     0= no rotation of interrupt priority
       1= rotate interrupt priority according to:
          bits 6 5 = 1 1 current IRn (bits 2-0) set to lowest priority
                     0 1 ignore bits 2-0
                     0 0 no EOI command will be issued
 6     0= disable bits 0-2
       1= enable bits 0-2
 5     0= do not issue EOI command to CPU
       1= issue EOI to CPU
4-3    0 0  OCW2 identifier
2-0    index of IRn for this command
</code></pre>
<p>Operation Command “Word” 3 to port 20H:</p>
<pre><code>bit    description
 7     not used
 6     0= ignore bit 5
       1= honor bit 5
 5     0= disable special mask mode
       1= enable special mask mode
4-3    0 1 OCW3 identifier
 2     0= poll command has not been issued
       1= override bit 1 and poll command has been issued
 1     0= no read register command issued
       1= read register command issued
 0     0= interrupt-request register will be read by read-status operation
       1= in-service register will be read by read-status operation
</code></pre>
<p>Interrupt status read:</p>
<p>  in al,021h    ; gives contents of interrupt-mask register<br>  mov ah,al<br>  in al,020h    ; gives contents of in-service register or<br>                ;  interrupt-request register, according to command<br>                ;   “word” 3 bit 0</p>
<p>Ports 40H-43H: The 8253 Timer Chip</p>
<p>Ports 44H,47H: PS/2 Watchdog Timer Counter and Control Port</p>
<p>The 8253 is a programmable three-channel 16-bit interval timer/counter,<br>occupying four ports from 040H to 043H.  Each channel can be used to<br>take an input clock signal 0-2MHz and produce an output signal by<br>dividing by an arbitrary 16-bit number.  Channel 0 is used to make the<br>time-of-day clock ticks, channel 1 is used to tell the DMA to refresh<br>the dynamic RAM, and channel 2 is used to make a audio signal for the<br>speaker.  Each channel can be programmed in one of six modes: 0=<br>interrupt on terminal count, 1= programmable one-shot, 2= rate<br>generator, 3= square-wave generator, 4= software-triggered strobe, 5=<br>hardware-triggered strobe.</p>
<p>Initialization:  Send a mode control byte for each channel to the 8253<br>control word register at 043H.  Send a count to timer port, one byte at<br>a time.</p>
<p>Mode Control byte sent to the Control register for Channels 0, 2</p>
<p>  bit    description<br>  7-6    counter number (0-2)<br>  5-4    latch read format<br>           00= latch current count for reading<br>           01= read/load high byte (no latching needed)<br>           10= read/load low byte (no latching needed)<br>           11= read/load low, then high byte<br>  3-1    mode number<br>           000=interrupt on terminal count<br>           001=programmable one-shot<br>           010=rate generator<br>           011=square wave generator<br>           100=software triggered strobe<br>           101=hardware triggered strobe<br>   0     0= count in binary<br>         1= count in BCD</p>
<p>Mode Control byte sent to the Control register of Channel 3:</p>
<p>  bit    description</p>
<p>  7-6    00 = select counter 3<br>         01 = R/W counter bits 0-7 only<br>  3-0    reserved, set 0</p>
<p>Counter Latch Command sent to the Control register of Channel 3:</p>
<p>  bit   Function<br>    7   SC1 - specifies counter to be latched<br>    6   SC0 - specifies counter to be latched<br>  5-4   00 = counter latch command<br>  3-0   reserved, set 0</p>
<p>Port assignments             Power-up mode byte  Power-up count on PC</p>
<p>040H  timer 0 TOD clock      036H mode 3         0=65536   (18.2Hz)<br>041H  timer 1 DMA refresh    054H mode 2         12H=18    (66 kHz)<br>042H  timer 2 Speaker tone   0B6H mode 3         553H=1331 (896 Hz sq.wave)<br>043H  control word register<br>       for channels 0-2<br>044H  counter 3<br>047H  control word register<br>       for channel 3</p>
<p>Channel 0: The System Timer:</p>
<p>The TOD clock is set by the BIOS to pulse every 18.2 times a second.  On<br>each pulse, Int 8 is generated.  The Int 8 service routine keeps a tally<br>at the double word at 40:6Ch.  The channel 0 system timer latch can be<br>cleared by a system reset, by the Int 8 service, or a write to port 61h<br>with bit 7=1.  Disk timing operations are also controlled bye this<br>service.</p>
<p>Channel 1: DMA Refresh Pulses:</p>
<p>The DMA refresh pulse causes the DMA chip to refresh all RAM.  This<br>channel should not be reprogrammed.</p>
<p>Channel 2: Tone Generation for Speaker:</p>
<p>The Speaker tone timer is connected to the computer speaker. The gate to<br>this timer are controlled by the 8255 interface chip.  The gate is<br>closed by sending bit 0 to 1 at port 61H.  The output to the speaker can<br>be close with bit 5 at port 62H.<br>An IN instruction at port 43H will place the data buffer in the high-<br>impedence state with no further operation.  The control word bit pattern<br>is:</p>
<p>   bits  7-6 Number of channel to program<br>         5-4 Kind of operation<br>              00 = move counter value into latch<br>              01 = read/write high byte only<br>              10 = read/write low byte only<br>              11 = read/write high byte, then low byte<br>         3-1 Mode number (0-5)<br>           0 If 0, binary data, else BCD</p>
<p>After the control word is sent OUT to port 43H, set channel 2 to enable<br>clock signal (bit 0) at port 60H.  Use 1 to drive speaker, 0 for timing<br>operations.  Send counter LSB to 42H, then MSB.</p>
<p>Channel 3: The Watchdog Timer (PS/2 only):</p>
<p>The watchdog timer and system channel time-out are not masked by sending<br>an 80H to port 70H.  The watchdog timer detects when IRQ0 is active for<br>more than one clock period.  If so, its counter is decremented.  When<br>the count reaches 0, a NMI is generated.  Thus, if the IRQ0 is not being<br>serviced, an error can be detected. When the watchdog timer sets a NMI,<br>then it also sets I/O 094h bit 4.  NMI stops arbitration until 090h bit<br>6 = 0.</p>
<p>Ports 60H-63H: PC 8255 Parallel I/O Port Chip for Keyboard and Status</p>
<p>Ports 60H-64H: PS/2 Intel 8042 Keyboard/Auxiliary Device Controller</p>
<p>The 8255 Parallel Port Controller and Programmable Peripheral Interface</p>
<p>The 8255 chips control parallel ports on the PC system, and acts as the<br>Programmable Peripheral Interface (PPI) for the CPU, occupying four<br>consecutive port addresses 060H-063H.  The PPI can control three<br>independent ports (A, B, and C) as either input or output.  The fourth<br>port address is used as a control port for the chip.  The following<br>shows the meaning of a control byte sent to the write-only control port:<br>         bit                        Value      Action<br>           7   Mode Set Flag          0  Inactive   1  Active<br>         6,5   Mode Selection A      00  Mode 0    01  Mode 1   1x  Mode 2<br>           4   Port A                 0  Output     1  Input<br>           3   Port C (upper 4 bits)  0  Output     1  Input<br>           2   Mode Selection B       0  Mode 0     1  Mode 1<br>           1   Port B                 0  Output     1  Input<br>           0   Port C (lower 4 bits)  0  Output     1  Input<br>If bit 7 is 0, the byte sent is used to set or reset a bit in port C.<br>Mode 1 uses three port C lines for handshaking and interrupt control of<br>port A.  For input, if PC4=0, port A latches data and PC5 goes high to<br>indicate ‘buffer full’ for device connected to input lines.  PC5 returns<br>low when the CPU reads port A.  If port A interrupts are enabled, PC3<br>also goes high when a byte is received, which can be used for an IRn<br>line to an 8259A interrupt controller.  Port B functions like port A in<br>mode 1 except it uses the three low bits of port C for control.  Output<br>in mode 1 is similar.  Mode 2 allows port A to operated bidirectionally,<br>with handshaking and interrupt control using five bits of port C.</p>
<p>The PPI Status Ports on the IBM PC compatibles at port addresses 060H to<br>062H perform the following functions (all set to mode 0, A made input, B<br>output, C input by sending 099H to 063H):</p>
<p>060H Port A Input (acts as a one byte device output register):</p>
<pre><code>    If PB7 = 0 Read Keyboard Scan Code


    If PB7 = 1 Read switches
           PA7,6   = SW1-8,7  # of drives
           PA5,4   = SW1-6,5  monitor type
                           11 = monochrome
                           10 = 80x25 color
                           01 = 40x25 color
           PA3,2,0 = SW1-4,3,1 Reserved
           PA1     = SW3       Math chip mounted
</code></pre>
<p>061H Port B Output (acts as a one byte device control register):</p>
<pre><code>           PB7 0 enable keyboard read
               1 clear keyboard and enable sense of SW1
           PB6 0 hold keyboard clock low, no shift reg. shifts
               1 enable keyboard clock signal
           PB5 0 enable i/o check
               1 disable i/o check
           PB4 0 enable r/w memory parity check
               1 disable r/w parity check
           PB3 0 turn off LED
               1 turn on LED (old cassettee motor off)
           PB2 0 read spare key
               1 read r/w memory size (from Port C)
           PB1 0 turn off speaker
               1 enable speaker data
           PB0 0 turn off timer 2
               1 turn on timer 2, gate speaker with square wave
</code></pre>
<p>062H Port C Input (acts as a one byte device output register):<br>                (Set PB2 (PC) or PB3 (XT) first.)</p>
<pre><code>           PC7 0 no parity error or PB4=1
               1 r/w memory parity check error
           PC6 0 no i/o channel error or PB5=1
               1 i/o channel check error
           PC5 0 timer 2 output 0
               1 timer 2 output 1
           PC4   reserved (old cassettee data input)
           PC3,2,1,0 = r/w memory (SW2-4,3,2,1) if PB2=1
                     =  spare key (SW2-8,7,6,5) if PB2=0


   PC7 and PC6 are used by the NMI handler to tell whether RAM parity
   error, i/o channel status error, or, if both are 0, an 8087 error
   occured.
</code></pre>
<p>Example: Direct reading of PC keyboard scan code (replacement for INT 09):</p>
<ol>
<li>Read scan code.  Note that “make” key scan code has bit 7=1,<br>“break” code has bit 7=0, except on AT, for which bit 7 is always 0,<br>a “break” produces a 0F0H code, then the key scan code.</li>
<li>Send acknowledge to keyboard by toggling bit 7 to 1, then back to 0.</li>
<li>Put keyboard in buffer.</li>
<li>Signal EOI to the interrupt controller.</li>
</ol>
<pre><code>   pushall
   in al,060h     ; get key code
   push ax        ; save it
   in al,061h     ; get current control
   mov ah,al      ; save PB control
   or al,80h      ; set keyboard bit
   out 061h,al    ; keyboard acknowledge
   xchg ah,al     ; get back PB
   out 061h,al    ; reset PB control
   pop ax         ; get back code
   ...            ; save code in buffer
   cli
   mov al,20h
   out 20h,al     ; send eoi to interrupt controller
   popall
   iret
</code></pre>
<p>The PS/2 8042 Keyboard/Auxiliary Device Controller</p>
<p>On the PS/2, an Intel 8042 chip replaces the 8255, using ports 60H and<br>64H. Port 61H serves as a system control port for compatibility with the<br>PC. The 8042 controls both the keyboard and an auxiliary device, such as<br>a mouse. It receives serial data, check parity, translates keyboard scan<br>codes, and presents data at the data port 60H.  The interface can<br>interrupt the system (IRQ1) or can wait for polling.  The I/O port 64H<br>is the command/status port. A read gives status, a write is interpreted<br>as a command.  The 8042 provides for a password security mechanism.</p>
<p>A read from port 64H gives the following status byte:</p>
<p>   Bit     Function<br>    7      1 = Parity error<br>    6      1 = General Time Out<br>    5      1 = Auxiliary output buffer full<br>    4      1 = Inhibit switch<br>    3      1 = Command/data<br>    2      1 = System flag<br>    1      1 = Input buffer full<br>    0      1 = Output buffer full</p>
<p>The status register can be read at any time.  The data port 60H should<br>be read only when the output buffer full bit in the status register is</p>
<ol>
<li>Data should be written to the 8042 input buffer only when the input<br>buffer full bit in the status register is 0.  If the auxiliary output<br>buffer full bit is 1, then the data read came from the auxiliary device.<br>The command port 64H should be written to only when the status register<br>input buffer full bit and the output buffer full bit are 0.  Devices<br>connected to the 8042 should be disabled before sending a command that<br>generates output.</li>
</ol>
<p>The following are recognized commands sent to port 64H:</p>
<p>  20-3FH   Read the 8042 RAM - Bits D5-D0 specify the address.<br>               Address 0 is the current command byte.</p>
<p>  60-7FH   Write to the 8042 RAM   - Bits D5-D0 specify the address.<br>               Address 0 will mean the next byte of data out at port 60H<br>               is the command byte, defined using:</p>
<pre><code>          Bit     Function
           7      Reserved = 0
           6      1 = IBM keyboard translate mode
           5      1 = Disable auxiliary device
           4      1 = Disable keyboard
           3      Reserved = 0
           2      1 = Place system flag in status register
           1      1 = Enable auxiliary interrupt
           0      1 = Enable keyboard interrupt


A4     Test if password is installed.  Data 0FAH on port 60H means
       that the password is installed, 0F1H means that the password
       is not installed.


A5     Load Security - initiate the password load procedure.  Following
       this command the 8042 will input from the data port until a
       null is detected.


A6     Enable Security - enable the security feature, when the password
       pattern is currently loaded.


A7     Diable auxiliary device interface - set bit 5 of the command
       byte.

A8     Enable auxiliary device interface - reset bit 5 of the command
       byte.


A9     Interface test - test the auxiliary device clock and data lines.
       The result is placed in the output buffer at 60H:


          Result      Meaning
            00        No error
            01        Aux. device clock line stuck low
            02        Aux. device clock line stuck high
            03        Aux. device data line stuck low
            04        Aux. device data line stuck high


AA     Self test - tests 8042.  A 55H is placed in output buffer if
       no errors are detected.


AB     Interface test - cause the 8042 to test the keyboard clock
       and data lines.  Result reported as in command A9.


AC     Reserved


AD     Disable keyboard interface - set bit 4 of the command byte.


AE     Enable keyboard interface - reset bit 4 of the command byte.


C0     Read input port - read the 8042 input port and put it in the
       output port.  If bit 3 is 0, the fuse on the +5 Vdc line
       on the system board to the keyboard is open.


C1     Poll input port low - put port 1 bits 0-3 in status bits 4-7.


C2     Poll input port high - put port 1 bits 4-7 in status bits 4-7.


D0     Read output port - put data from output port into the output
       buffer.


D1     Write output port - put next byte written to 60H into the
       output port.  Caution:  Bit 0 of the output port is connected
       to the System Reset line.  This bit should not be written low.


D2     Write keyboard output buffer - put next byte written to 60H
       into output buffer and issue device interrupt if enabled.
       This produces a simulated keyboard output.


D3     Write auxiliary device output buffer - put next byte written
       to 60H input buffer in output buffer as if initiated by the
       auxiliary device and issue interrupt if enabled.


D4     Write to auxiliary device - transmit next byte written to 60H
       input buffer to auxiliary device.


E0     Read test inputs - cause the 8042 to read its T0 and T1 inputs.
       This data is placed in the output buffer bits 0 and 1.
</code></pre>
<p>  F0-FF    Pulse output port - pulse bits 0-3 of the 8042 output port<br>           for about 6 usec.  Bits 0 to 3 indicate which bits are to be<br>           pulsed.  A 0 indicates bit should be pulsed.  Caution:<br>           Bit 0 of the 8042 output port is connected to the System Reset<br>           line.  Pulsing this bit resets the system microprocessor.</p>
<p>On the PS/2, the 8042 controller can pass commands to the keyboard<br>through port 60H:</p>
<pre><code>ED     Set/reset status indicators. Rresponse is ACK (0FAH), system
       acceptance of ACK requires system to raise clock and data lines
       for at least 500 usec.


EE     Echo test (valid response is EE)


EF     Invalid command


F0     Select alternate scan codes (response is ACK, system then sends
       option byte of 01, 02, or 03, response is ACK)


F1     Invalid command


F2     Read keyboard ID (response is ACK plus two ID bytes of 83ABH)


F3     Set typematic rate/delay (response is ACK, system sends rate/delay
       byte, response is ACK.  The rate/delay byte is:


          bit      function


           7       reserved = 0
          6-5      (delay/250msec - 1)
          4-3      doubling factor of rate
          2-0      (rate/(240/sec) - 8)


F4     Enable (response is ACK, clears buffer, clears last typematic
       key, and starts scanning).


F5     Default disable (resets all conditions to power-on state, sends
       ACK, stops scanning).


F6     Set default (resets to power-on state, sends ACK, sets default
       key types for scan code 3, continues scanning).
</code></pre>
<p>  F7-FA    Set all keys to typematic, make/break, make, or typematic/make/<br>           break for scan code 3 (responds with ACK).</p>
<p>  FB-FD    Set a key type to typematic, make/break, or make (response is<br>           ACK, then keyboard prepares to receive key scan code from set 3.</p>
<pre><code>FE     Send the previous output again.


FF     Reset the keyboard and start internal self-test. Response is
       ACK.  System must acknowledge ACK by raising clock and data lines
       for over 500 usec.  Following acceptance of ACK, keyboard is
       reinitialized and performs a Basic Assurance Test (BAT).  The
       keyboard defaults to scan code 2.
</code></pre>
<p>The PS/2 keyboard may send the following codes to the system:</p>
<pre><code>00     Key detection error/overrun under scan code 2 or 3.
</code></pre>
<p>   83AB    Keyboard ID bytes.</p>
<pre><code>AA     Basic Assurance Test completed.


FC     Basic Assurance Test failed.


EE     Echo of EE command.


FA     ACK code.


FE     Resend. Invalid input or parity error.


FF     Key detection error/overrun under scan code 1.
</code></pre>
<p>Port 61H: PS/2 System Control Port B</p>
<p>Write operations:</p>
<p>   Bit   Function</p>
<pre><code>7    Reset system timer 0 output latch (IRQ0)
6    Reserved
5    Reserved
4    Reserved
3    Enable channel check
2    Enable parity check
1    Speaker data enable
0    System timer 2 gate to speaker
</code></pre>
<p>Read operations:</p>
<pre><code>7    1 = Parity check occurred
6    1 = Channel check occurred
5    System timer 2 output
4    Toggles with each refresh request
3    Enable channel check result
2    Enable parity check result
1    Speaker data enable result
0    System timer 2 gate to speaker result
</code></pre>
<p>Ports 70H and 71H: Configuration Ports and Real-Time-Clock Chip MC146818</p>
<p>The AT and PS/2 uses port 70H bit 7 to disable ‘Non-Maskable’ Interrupts<br>(NMI) by setting bit 7 to 0.  Enable NMI by setting bit 7 to 1.  Note:<br>the PCs use port 0A0H for this purpose.  Port 70H on ATs is also used to<br>set a CMOS register index (00-3FH), which is then read from port 71H.<br>Even when masking the NMI through bit 7 of port 70H, read port 71H<br>immediately after.  Otherwise, the RTC may be left in an unknown state.<br>The watchdog timer and system channel time-out are not masked by sending<br>an 80H to port 70H.</p>
<p>The AT stores configuration settings on a Motorola MC146818 real time-<br>clock-chip (RTC).  (Programming information for the RTC is given later.)<br>Because the CMOS chip is supplied by a battery, configuration parameters<br>are saved even during power-off. The chip has 64 registers (00-3FH) read<br>from port 71H after sending the register index to 70H.  Below are some<br>register allocations:</p>
<p>  Register   Use</p>
<pre><code>00H      Real-Time-Clock seconds
01H      Real-Time-Clock seconds alarm
02H      Real-Time-Clock minutes
03H      Real-Time-Clock minutes alarm
04H      Real-Time-Clock hours
05H      Real-Time-Clock hours alarm
06H      Real-Time-Clock day of week
08H      Real-Time-Clock day of month
09H      Real-Time-Clock month
09H      Real-Time-Clock year
0AH      Real-Time-Clock Status of register A
          (Bit 7 = 1 - time update in progress
              6-4= 22 stage divider, clock freq. (010=32.768 KHz)
              3-0= rate selection, divider output freq. (0110=1.024 KHz)
0BH      Real-Time-Clock Status of register B
          (Bit 7 = Set update
               6 = periodic interrupt enabled
               5 = alarm interrupt enabled
               4 = update-ended interrupt enabled
               3 = square wave enable
               2 = date mode in binary (0=BCD)
               1 = hours counted by 24
               0 = daylight savings time enabled
0CH      Real-Time-Clock Status of register C
          (Bit 7 = IRQF flag
               6 = PF flag
               5 = AF flag
               4 = UF flag
              3-0= reserved = 0
0DH      Real-Time-Clock Status of register D
          (Bit 7 = Valid RAM bit (0=battery dead)
              6-0= reserved = 0
0EH      Diagnostic status byte
          Bits   7 RTC lost power
                 6 bad checksum
                 5 invalid configuration
                 4 inconsistent memory size
                 3 hard disk error
                 2 POST time check error
               1-0 reserved
0FH      Shut-down byte

10H      Diskette drive type
          Bits 7-4 first diskette   0000 = no drive
               3-0 second diskette  0001 = 48 tpi drive
                                    0010 = 96 tpi drive
11H      Reserved
12H      Fixed disk drive type
          Bits 7-4 first hard disk  Drive code
               3-0 second hard disk Drive code
13H      Reserved
14H      Peripherals (Equipment Byte)
          Bits 7-6 number of diskette drives - 1
               5-4 display 00=display has own BIOS
                           01=40 column color
                           10=80 column color
                           11=monochrome
               3-2 unused
                 1 1=math coprocessor installed
                 0 0=no diskette drives, 1=diskettes installed
15H      LSB of system board memory
16H      MSB of system board memory
           ;In 1024 byte blocks, 512K increments)
17H      LSB total expansion memory
18H      MSB total expansion memory
           ;In 1024 byte blocks, 512K increments)
19H      Drive C extension byte
1AH      Drive D extension byte
1BH-2DH  Reserved
2EH-2FH  2 byte checksum (high, low) 10-2DH except 0E and 0FH
30H      LSB expansion memory above 1 megabyte
31H      MSB expansion memory above 1 megabyte
           ;In 1024 byte blocks, 512K increments)
32H      Data century byte
33H      Information flags set during power-up
34H-3FH  Reserved
</code></pre>
<p>The Real-Time-Clock (RTC) on the AT and PS/2 uses the registers<br>addressed at port 70H and read from 71H.  Use Int 1Ah to read and set<br>the time-of- day and alarm.  The alarm interrupt, Int 4Ah, must have a<br>service routine vector before the alarm is set.</p>
<p>Port: 90H: PS/2 Central Arbitration Register</p>
<pre><code>          Reads                           Writes
Bit 7 Enable System Microprocessor Cycle  ESMC
    6 Arbitration Mask by NMI             Arbitration Mask
    5 Bus Timeout                         Enable Extended Arbitration
    4 = 0 Reserved                        = 0 Reserved
  3-0 Value of Arb.Bus During Previous    = 0 Reserved
      Grant State
</code></pre>
<p>Port: 92H: PS/2 System Control Port A</p>
<p>This port supports the fixed disk drive lights, alternate system<br>microprocessor reset, PASS A20, watchdog timer status, and CMOS<br>security:</p>
<p>  Bits 7,6  Fixed disk activity light A, B<br>        5   Reserved = 0<br>        4   1 = Watchdog Timer timeout has occurred<br>        3   1 = RT/CMOS secure area (password) locked by POST<br>        2   Reserved = 0<br>        1   Alternate Gate A20 address line (1=active)<br>        0   Alternate CPU reset (to effect mode switch from<br>            Protected Virtual Address Mode to Real Address Mode).<br>            Reset time: 13.4 usec.  (The AT Intel 8042 method<br>            is also supported.)</p>
<p>Ports 94H to 96H:  System Setup</p>
<pre><code> Port 94H System Board Enable/Setup Register
          (System incluses diskette controller, serial, and parallel
          controllers.  Set to 0FFH when setup is complete)
         Bits  7 = 0 to setup other system boards with I/O 100H to 107H
                 = 1 to avoid setup of other system boards
               5 = 0 to setup video subsystem with I/O 100H to 107H
                   1 to avoid setup of VGA
      96H Adapter Enable/Setup Register
           (Set to 00H when setup is complete)
               3 = 1 for adapter setup with I/O 100H to 107H
                   0 to avoid setup of an adaptor
</code></pre>
<p>Ports 100H-107H: PS/2 Program Option Select (POS)</p>
<pre><code> 100    PS/2 POS Reg.0 Adapter ID LSByte
 101    PS/2 POS Reg.1 Adapter ID MSByte
 102    PS/2 POS Reg.2 Option Select Date Byte 1
         Bit 7 = Enable/Disable Parallel Poort Extended Mode
             6 = Parallel Port Select high bit
             5 = Parallel Port Select low bit
                  0 = 3BC-3BE  2 = 278-27A
                  1 = 378-37A  3 = reserved
             4 = Enable/Disable Parallel Port
             3 = Serial Port Select
             2 = Enable/Disable Serial Port
             1 = Enable/Disable Diskette Drive Interface
             0 = Enable/Disable System Board or Card Enable
 103    PS/2 POS Reg.3 Option Select Data Byte 2
 104    PS/2 POS Reg.4 Option Select Data Byte 3
 105    PS/2 POS Reg.5 Option Select Data Byte 4
     Bit 7 = CHCK Channel Check (Set by adapter if error)
     Bit 6 = STAT Channel Check Status Indicator
            0 = status available at 106, 107
 106    PS/2 POS Reg.6 Subaddress Extension LSB
 107    PS/2 POS Reg.7 Subaddress Extension MSB
</code></pre>
<p>Only 8 bit I/O is supported on POS ports.</p>
<p>When video subsystem is in setup mode (port 94H bit 5=0), VGA responds<br>to a single option select byte at port 102H and treats the bit 0 as a<br>sleep bit.  If bit 0 is 0, the VGA does not respond to commands,<br>addresses, or data.  The VGA responds only to port 102H when in setup<br>mode. Conversely, VGA ignores address 102H when in the enable mode (94H<br>bit 5=1).</p>
<p>Port 0A0H: The PC NMI Mask Register</p>
<p>The ‘Non-Maskable’ Interrupt line to the CPU automatically generates an<br>Int 2 for handling disastrous situations, such as power failure, memory<br>parity error, math coprocessor error, etc.  On PCs, port at 0A0H is<br>reserved to hold a mask to disable this line before it reaches the CPU.<br>Bit 7 set enables the NMI, while bit 7=0 disables it.  On the AT and<br>PS/2, use port 070H for the same purpose (read port 71H after to clear<br>the pending read state of the CMOS RAM).</p>
<p>Ports 0F0H-0FFH: 80x87 Math Coprocessor</p>
<p>Clear math coprocessor busy signal by sending 0 to port F0H.  Reset<br>math coprocessor by sending 0 to port F1H.</p>
<p>Port 201H: The Game Port (PC, XT, AT)</p>
<p>Port 201H contains the status of buttons 2,1 of stick B, 2,1 of stick A<br>in bits 7-4.  Bits 3-0 are set to zero by sending any byte to 201H. The<br>time it takes for these bits to become 1 determines the Y,X position of<br>stick B, Y,X position of stick A.</p>
<p>Ports 278H-27AH, 378H-37AH, 3BCH-3BEH LPT3,2,1 Printer Ports</p>
<p>These ports are used on the PC, XT, AT, and PS/2 for parallel devices.<br>The base port addresses are stored in locations 40:08 to 40:0D.  If the<br>address value is zero, that port is not available, nor are any which<br>follow.</p>
<p>The parallel ports have the designations:</p>
<pre><code> Base port:  Data Output
 Base + 1 :  Status: Reports printer condition and errors
             Bit   7 0=printer busy (pin 11)
                   6 0=acknowledge data byte received (pin 10)
                   5 1=printer out of paper (pin 12)
                   4 0=printer off line (de-select) (pin 13)
                   3 0=printer error (pin 15)
                 2-0 unused
 Base + 2 :  Control: Initializes adapter and controls output
             Bit 7-5 unused
                   4 1=printer interrupt enabled (IRQ status)
                   3 0=printer de-selected (inverted pin 17)
                   2 0=initialize port (delay 1/20 second after reset)
                       (pin 16)
                   1 0=no linefeed after CR (pin 14)
                   0 1=output a byte of data - strobe (pin 1)
</code></pre>
<p>To test if the printer is on-line, first check the existence of the<br>printer port starting at 40:08 for LPT1:.  Three parallel port words are<br>defined.  If a 0 value is encountered, that and further ports do not<br>exist.  Next, check the printer status byte, bits 3-5.  Do not begin<br>printing until the status register indicates that the printer is on-line<br>and ready to receive data.  Monitor bit 7 between each byte of data<br>sent.</p>
<p>Almost universally, Int 17h is used to control parallel printers.  (This<br>is in contrast with serial devices, for which direct chip access is<br>common.)</p>
<p>The following code shows how the printer port can be handled directly<br>using polling of the status byte:</p>
<pre><code>    MOV DX,BASE_PORT      ; LPTx port address
    LDS SI,DATA_BUFFER    ; characters to send to printer
    MOV CX,DATA_SIZE      ; number of characters to send
</code></pre>
<p>NEXT:   LODSB                 ; get character<br>        OUT DX,AX             ; send it<br>        INC DX<br>        INC DX                ; get control register<br>        MOV AL,00001101B      ; strobe bit set<br>        OUT DX,AL             ; send strobe signal<br>        DEC DX                ; get status byte<br>BUSY:   IN AL,DX              ;  into al<br>        TEST AL,8             ; test for error<br>        JZ PRT_ERROR<br>        TEST AL,80H           ; check for busy<br>        JZ BUSY<br>        DEC DX                ; get data port<br>        LOOP NEXT             ; continue<br>        …<br>Because of the printer, the routine will be slow without print buffering.</p>
<p>An interrupt routine should be avoided with the printer port on the PC<br>monochrome adaptor, due to a hardware fault.  Instead, use the system<br>timer to determine the polling frequency.  Interrupt driven routines can<br>be used on the AT and PS/2.</p>
<p>Ports 2E8-2EEH, 2F8-2FEH, 3E8-3EEH, 3F8-3FEH COM4,3,2,1</p>
<p>The 8250 Asynchronous Communication Effector (ACE) is used for control<br>of the serial ports on the PC.</p>
<p>The AT uses a NS16450, a 16-bit version of the 8250.  The PS/2 uses a<br>NS16550 which is functionally upward compatible with the NS16450 and the<br>8250.</p>
<p>The 8250 UART (universal asynchronous receiver/transmitter) converts<br>parallel data on the CPU’s data bus into serial data (50 to 19200 baud)<br>by dividing the input clock frequency by a programmable 16-bit number.<br>It occupies seven sequential port addresses.  For the first serial port<br>on the PC, these are at 3F8-3FFH.  The second serial port occupies<br>2F8-2FFH.  The following internal registers are set or read by in or out<br>instructions to the corresponding port offset relative to the first<br>assigned port value below:</p>
<p>Port<br>Offset–&gt; 0        1        2        3        4        5        6</p>
<p>Reg.   Rec/Trans  Int      Int     Line     Modem    Line     Modem<br>Name     Buff    Enable    ID     Contrl    Contrl  Status    Status</p>
<pre><code>  .--------+--------+--------+--------+--------+--------+--------.
</code></pre>
<p> bit  |  data  |  rec   |  0 if  |  word  | data   | data   | delta  |<br>  0   | bit 0  |  data  |pending | length |terminal| ready  |clear to|<br>      |        |  int   |        | bit 0  | ready  |        | send   |<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  | trans  | int id |  word  |request | over-  | delta  |<br>  1   | bit 1  |  data  | bit 0  | length |to send |  run   |data set|<br>      |        |  int   |        | bit 1  |        | error  | ready  |<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  |  line  | int id | no. of | out 1  | parity |trailing|<br>  2   | bit 2  | status | bit 1  |stopbits|        | error  | edge   |<br>      |        |  int   |        | - 1    |        |        |ring ind|<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  | modem  |        | parity | out 2  | frame  | delta  |<br>  3   | bit 3  | status |   0    | enable |        | error  |rec.line|<br>      |        |  int   |        |        |        |        |sig.det.|<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  |        |        |  even  | loop   | break  | clear  |<br>  4   | bit 4  |   0    |   0    | parity | back   | inter. |  to    |<br>      |        |        |        |        |        |        |  send  |<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  |        |        |  stick |        |trans.  | data   |<br>  5   | bit 5  |   0    |   0    | parity |   0    |holding |  set   |<br>      |        |        |        |        |        |reg.empty  ready |<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  |        |        |  set   |        |trans.  | ring   |<br>  6   | bit 6  |   0    |   0    | break  |   0    |shift   |indicat.|<br>      |        |        |        |        |        |reg.empty        |<br>     -+——–+——–+——–+——–+——–+——–+——–|<br> bit  |  data  |        |        |divisor |        |        |rec.line|<br>  7   | bit 7  |   0    |   0    | latch  |   0    |   0    |sig.det.|<br>      |        |        |        | access |        |        |carrier |<br>      `————————————————————–’</p>
<p>Port offset 7 (e.g. 3FFH) is not used.</p>
<p>If the divisor-latch-access bit is set to 1, then the baud latch divisor<br>can be read or set byte reading or writing to port 0 (LSB) and port 1<br>(MSB). The clock signal on the chip at 1.8432 MHz is divided by the<br>divisor to get the output of the baud generator which is 16x the baud<br>rate.  Thus the divisors for common baud rates are:</p>
<p>  Baud         Divisor Latch   Decimal<br>  Rate          MSB     LSB     Value</p>
<p>   300          01      80H     384<br>  1200          00      60H      96<br>  2400          00      30H      48<br>  9600          00      0CH      12<br> 19200          00      06H       6</p>
<p>Reset bit 7 of the line control register in order to access the data and<br>other registers.</p>
<p>The Line Control Register:</p>
<p>The word length, number of stop bits, and parity are set with an out to<br>the line control register.  The first two bits are defined to make a<br>word length using:</p>
<p>  Bit 1  Bit 0  Word Length</p>
<pre><code>0      0       5
0      1       6
1      0       7
1      1       8
</code></pre>
<p>If bit 2 is 1 when bits 1 and 0 are 00, then 1.5 stop bits are<br>generated. If bit 3 is 0, no parity will be used and 8 bit data may be<br>transmitted. If bit 3 is 1 and bit 4 is 0, odd parity is used. If bit 5<br>is 1 and bit 3 is 1, parity is transmitted as bit 4 indicates, but<br>received in the opposite state.  Setting bit 6 to 1 forces the output to<br>logic 0. It remains there until bit 6 is reset.</p>
<p>The Line Status Register:</p>
<p>Bit 0 is set 1 whenever a byte has been received in the receive buffer<br>register.  It is reset by reading the data or writing to this bit.</p>
<p>Bit 1 is set 1 if an overrun error from the line status register<br>indicates data in the receive buffer register was not read by the CPU<br>before another was transferred in.  It is reset by reading the line<br>status register.</p>
<p>Bit 2 is set 1 if a parity error is detected in the received data.  It<br>is reset by reading the line status register.</p>
<p>Bit 3 is set 1 if a framing error is detected, i.e. the received<br>character did not have a valid stop bit.</p>
<p>Bit 4 is set 1 if the received data is held to 0 for longer than a full<br>word transmission time (start bit + data bits + parity + stop bits).</p>
<p>Bit 5 is set 1 if the transmitter holding register is empty.  It is<br>reset by loading the transmitter holding register.</p>
<p>Bit 6 is set 1 if the transmitter shift register is empty.  It is reset<br>by data tranfer to it from the transmitter holding register.</p>
<p>Interrupt Identification Register:</p>
<p>Three bits are used to identify the type of interrupt generated by the<br>chip. Bit 0 is set 0 if an interrupt is pending.</p>
<p> Bits 2 and 1 are set as follows:</p>
<pre><code>  1     1   if  a receive line status interrupt occurred
                  (overrun, parity, framing, or break error)
  1     0   if  a receive data interrupt occurred
                  (data ready to be read)
  0     1   if  a transmitter holding empty interrupt occurred
                  (trans. holding reg. just emptied)
  0     0   if  a modem status interrupt occurred
                  (CTS, DSR, RI, or Rec. Line Signal Detect-Carrier)
</code></pre>
<p>Modem Control Register:</p>
<p>The Data Terminal Ready line can be made high by a logic 1 to bit 0 of<br>this register. Similarly, a 1 in bit 1 will set the Request to Send<br>line to the modem.  The Out 1 line is not used in the IBM PC.  However,<br>Out 2 must be set to 1 to enable the serial chip to interrupt the CPU<br>over its interrupt line.</p>
<p>Modem Status Register:</p>
<p>The modem status register indicates the state and changes in the input<br>lines to the serial port.  The delta bits will be set 1 if the<br>corresponding lines have changed state since the last read of this<br>register.  The Receive Line Signal Detect line is also called the<br>Carrier Detect line (RS-232 pin 8).</p>
<p>Sample Initialization Code:</p>
<p>   MOV BX,3F8H         ; com1 port<br>   LEA DX,[BX+4]       ; use modem control port<br>   XOR AL,AL           ; set for all line off (dtr,rts,out1,out2)<br>   OUT DX,AL           ; send it<br>   LEA DX,[BX+1]       ; use interrupt enable port<br>   OUT DX,AL           ; set all interrupts off<br>   MOV AL,83H          ; set for 8 bit, 1 sb, divisor latch<br>   LEA DX,[BX+3]       ; get line control port<br>   OUT DX,AL           ; send it<br>   MOV AX,0060H        ; divisor for 1200 baud<br>   MOV DX,BX           ; lsb of divisor port<br>   OUT DX,AL           ; send it<br>   INC DX              ; msb of divisor port<br>   XCHG AL,AH          ; set up byte<br>   OUT DX,AL           ; send it<br>   NOP                 ; give chip a little time<br>   LEA DX,[BX+3]       ; line control port<br>   IN AL,DX            ; get back the line control byte<br>   NOP                 ; give chip a little time<br>   AND AL,7FH          ; drop divisor latch<br>   OUT DX,AL           ; set line control byte<br>   …                 ; set up interrupt service routine<br>   …                 ; and 8259 mask for int 0ch<br>   LEA DX,[BX+4]       ; modem control register<br>   MOV AL,0BH          ; set for dtr,rts,out2<br>   OUT DX,AL           ; send it<br>   NOP                 ; give chip a little time<br>   LEA DX,[BX+1]       ; interrupt enable port<br>   MOV AL,0FH          ; use RD, TD, LS, MS interrupts<br>   OUT DX,AL           ; set interrupt enable register<br>   …</p>
<p>(Do not follow one OUT instruction by another on an AT or PS/2.  Use a<br>delay instruction: JMP $+2 between them.  MOV AH,AL between two OUT<br>instructions still does not leave enought time for the port hardware to<br>recover.)</p>
<p>Ports 3B4H and 3D4H: The Motorola 6845 Video CRT Controller Address Register<br>Ports 3B8H-3BAH and 3D8H-3DAH: The Motorola 6845 Video CRT Control/Status</p>
<p>The 6845 cathode ray tube controller is used on the PC for both<br>monochrome and color video systems.  The PS/2 VGA system provides some<br>emulation for both of these controllers at the hardware level.</p>
<p>The 6845 controller uses four I/O ports 3B4H, 3B5H, 3B8H, and 3BAH on<br>the monochrome card (substitute ‘D’ for ‘B’ for color card).</p>
<p>Port 3B4H is the 6845 index register, to which a control register value<br>of 0 to 17 is sent before a read/write to the data register 3B5H.</p>
<p>The 6845 has 18 control registers, 0-17.  The first ten fix the<br>horizontal and vertical display parameters.  Incorrect settings of<br>registers 1-9 can damage a monitor.  Registers 10 and 11 set the shape<br>of the cursor; 14 and 15 control its location.  Registers 12 and 13 can<br>handle scrolling. Numbers 16 and 17 report light pen position.<br>Registers 12-15 are read/write.  Registers 16-17 are read only. All<br>other registers are write-only.</p>
<pre><code>    6845 Internal Registers:        VGA Emulation and Extension:
</code></pre>
<p>R0:  Horizontal total characters        (Total characters less 5)<br>R1:  Horizontal displayed characters    (Display char./line -1)<br>R2:  Start Horizontal blanking<br>R3:  End Horizontal blanking<br>R4:  Vertical total lines               Start Hor. Retrace Pulse<br>R5:  Vertical total adjust raster       End Hor. Retrace<br>R6:  Vertical display line              Vert. Total -2 (low 8 bits)<br>R7:  Vertical sync position line        Overflow  (see below)<br>R8:  Interlace:                         Preset Row Scan (see below)<br>     00           10=non-interlace<br>     01=duplicate 11=different<br>R9:  Maximum raster address             Max. Scan Line (see below)<br>R10: Cursor Start raster<br>R11: Cursor End raster<br>R12: Start address high<br>R13: Start address low<br>R14: Cursor high<br>R15: Cursor low<br>R16: Light pen high                     Vertical Retrace Start<br>R17: Light pen low                      Vertical Retrace End (see below)<br>R18:                                    Vertical Display Enable End<br>R19:                                    Underline Location<br>R20:                                    Start Vertical Blank<br>R21:                                    End Vertical Blank<br>R22:                                    CRTC Mode Control<br>R23:                                    Line Compare</p>
<p>The VGA emulation of the 6845 allows all registers to be read/write.</p>
<p>Port 3B8H is a CRT control port:</p>
<p>  Bit    Function             PS/2 Emulation: None</p>
<p>  7-6    Reserved<br>   5     Blink enable<br>   4     Reserved<br>   3     Video enable<br>  2-1    Reserved<br>   0     High resolution mode</p>
<p>Port 3BAH is a CRT read/only status port and a write/only feature<br>control port on the PS/2.  As a read/only port:</p>
<p>  Bit    Function            PS/2 Extension: Input Status Register 1</p>
<p>  7-6    Reserved            Reserved<br>   5     Reserved            Attribute controller diagnostic 0<br>   4     Reserved            Attribute controller diagnostic 1<br>   3     Video dots          Vertical retrace<br>  2-1    Reserved            Reserved<br>   0     Horizontal sync     Display enable (1=hor. or vert. retrace)</p>
<p>As a write/only port on the PS/2, the Write Feature Control Register,<br>all bits are reserved (bit 3 must be 0).</p>
<p>On the Hercules Graphics Controller, bit 7 may be used to distinguish<br>a Hercules card from an IMB Monochrome or Color Adapter.  On the<br>Hercules card, bit 7 goes 0 on vertical retrace (50 Hz).  On the<br>IBM card, bit 7 does not change.  The Hercules and the Hercules Plus<br>can be distinguished with bits 4 and 5 (1 and 0 for Plus).</p>
<p>Ports: 3C0H-3CFH: VGA Support</p>
<p>In addition to emulation for the 6845 status, index, and control ports,<br>the VGA system on the PS/2 uses the ports 3C0H-3CFH for additional video<br>status information and control.</p>
<p>Input Status Register 1:       3BAH or 3DAH: (R)</p>
<p>  Bit    Function<br>  7-6    Reserved = 0<br>  5-4    Diagnostic 0,1  Selectively connected to two of eight<br>   3     Vertical Retrace<br>  2-1    Reserved = 0<br>   0     Display Enable</p>
<p>Attribute Registers:           3C0H-3C1H:</p>
<p>Attribute Controller Registers:</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved = 0<br>   5     Palette Address Source<br>          (Set 0 when loading color palette registers)<br>  4-0    Attribute Address</p>
<p>Each attribute data register is written at 3C0H and read from 3C1H.  To<br>initialize the address flip-flop, issue IOR to 3BAH or 3DAH.  Then load<br>the attribute controller register. This toggles the flip-flop for a OUT<br>to the indexed data register. The flip-flop is not toggled by a read<br>from 3C1H.</p>
<p>Palette Registers: Index 00 to 0FH:</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved = 0<br>  5-0    P5-P0  Used to map color input to display color</p>
<p>Attribute Mode Control Register: Index 10H:</p>
<p>  Bit    Function</p>
<p>   7     P5, P4 Select 1=source from bits 1,0 of Color Select Register<br>   6     PEL Width - 1 for 256-color mode<br>   5     PEL Panning Compatibility<br>   4     Reserved = 0<br>   3     Select Background Intensity<br>   2     Enable Line Graphics Character Code (0=ninth dot same as backgnd)<br>   1     Mono Emulation<br>   0     Graphics/Alphanumeric Mode (1=graphics)</p>
<p>Overscan Color Register: Index 11H:</p>
<p>  Bit    Function</p>
<p>  7-0    P7-P0 Border color</p>
<p>Color Plane Enable Register: Index 12H:</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved = 0<br>  5-4    Video Status MUX - Selects 2 of 8 color outputs for status port<br>  3-0    Enable Color Plane</p>
<p>Horizontal PEL Panning Register: Index 13H:</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>  3-0    Horizontal PEL Panning (number of pixels to pan)</p>
<p>Color Select Register: Index 14H:</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>  3-2    S_color76 - two high-order bits of 8 bit color value<br>  2-0    S_color54 - replaces P5 and P4 in Attrib.Palette Reg.</p>
<p>Read Input Status Register 0:  3C2H: (R)</p>
<p>  Bit    Function<br>   7     CRT interrupt 1 = vertical retrace interrupt pending<br>  6-5    Reserved<br>   4     Switch Sense Bit: Lets POST determine monochrome or color<br>  3-0    Reserved</p>
<p>Write Misc. Output Register:   3C2H: (W)<br>Read  Misc. Output Register:   3CCH: (R)</p>
<p>  Bit    Function<br>   7     Vert. sync polarity 0 = positive retrace<br>   6     Hor. sync polarity  0 = positive retrace<br>           bits 7,6= 1 0 for 400 lines<br>                     0 1 for 350 lines<br>                     1 1 for 480 lines<br>   5     Page bit for odd/even (dianostic use) 1 = high 64K page<br>   4     Reserved = 0<br>  3-2    Clock select<br>          0 0 = 25.175 MHz for 640 hor. pixels<br>          0 1 = 28.322 MHz for 720 hor. pixels<br>          1 0 = external clock at aux. video input (14.3-28.4 MHz)<br>          1 1 = reserved<br>   1     Enable RAM 0 = disable video RAM address decode from CPU<br>   0     I/O address select - CRTC I/O 0 = 3BxH, 1 = 3DxH</p>
<p>Video Subsystem Enable:        3C3H:</p>
<p>  Bit    Feature</p>
<p>  7-1    Reserved<br>   0     Video subsystem enable: 1 = video I/O and memory address<br>         decoding is enabled.</p>
<p>This register is not affected by the VGA sleep bit (102H bit 0).</p>
<p>Sequencer Registers:           3C4H-3C5H:</p>
<p>Sequencer Address Register:    3C4H:</p>
<p>This register is loaded with a index to the following Sequence<br>Data registers:</p>
<p>Sequence Data Registers:       3C5H:</p>
<p>Reset Register (R/W) (Index 0):</p>
<p>  Bit    Function</p>
<p>  7-2    Reserved<br>   1     Synchronous reset 0 = synchr. clear and halt (before Clocking<br>                      Mode register bit 0 or Misc. Output Register bit 2)<br>   0     Asynchronous reset 0 = asynchr. clear and halt</p>
<p>Clocking Mode Register (R/W) (Index 1):</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved = 0<br>   5     Screen off  1 = screen off (use for rapid full-screen update by<br>           giving CPU maximum memory bandwidth)<br>   4     Shift 4  0 = video serializers are loaded every char. clock,<br>                  1 = video serializers loade every fourth clock (use<br>                      with 32 bit fetches/cycle)<br>   3     Dot clock 0 = select normal dot clock, 1 = master clock/2<br>                       (clock/2 used for 320 and 360 hor. pixel modes)<br>   2     Shift load: if 0 and if bit 4=0, video serializers reloaded<br>                       every char. clock, when 1, every other char. clock<br>                       (use with 16 byt fetches/cycle)<br>   1     Reserved = 0<br>   0     8/9 dot clocks 0 = char. clocks 9 dots wide.</p>
<p>Map Mask Register (R/W) (Index 2):</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>   3     Map 3 enable 1 = CPU can write to map 3<br>   2     Map 2 enable<br>   1     Map 1 enable<br>   0     Map 0 enable</p>
<p>If this register is set to 0FH, the system microprocessor can perform<br>32 bit wide write in only one memory cycle.</p>
<p>Character Map Select Register (R/W) (Index 3):</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved = 0<br>   5     Character Map select high bit A<br>   4     Character Map select high bit B<br>  3-2    Character Map select A<br>  1-0    Character Map select B</p>
<p>In alphanumeric modes, bit 3 of the attribute byte normally is used<br>to control foreground intensity.  This bit may be redefined, however,<br>to switch between character sets.  For this feature to be enabled,<br>the following must be true:</p>
<p>  Memory Mode register bit 1 = 1<br>  Character Map Select A is not the same as Character Map Select B</p>
<p>If either is not true, the first 16K of Map 2 is used.</p>
<p>For selection A:</p>
<p>Bit  5   3   2   Map  Table Location</p>
<pre><code> 0   0   0    0   1st 8K of Map 2
 0   0   1    1   3rd 8K of Map 2
 0   1   0    2   5th 8K of Map 2
 0   1   1    3   7th 8K of Map 2
 1   0   0    4   2nd 8K of Map 2
 1   0   1    5   4th 8K of Map 2
 1   1   0    6   6th 8K of Map 2
 1   1   1    7   8th 8K of Map 2
</code></pre>
<p>Similarly for selection B using bits 4, 1, and 0.</p>
<p>Memory Mode Register (R/W) (Index 4)</p>
<p>  Bit    Function<br>  7-4    Reserved = 0<br>   3     Chain 4   0 = enable CPU to access data at addresses within<br>                       bit map using Map Mask register.<br>                   1 = enable CPU to access data at addresses according<br>                       to two low order bits of address A1, A0:<br>                        00=map 0, 01=map 1, 10=map 2, 11=map 3.<br>   2     Odd/even  0 = use maps 0,2 or 1,3 according to parity of address.<br>                   1 = access data sequentially using Map Mask register<br>   1     Extended memory 1 = greater than 64K video memory present<br>   0     Reserved = 0</p>
<p>Digital to Analog Converter Registers: 3C6H-3C9H:</p>
<p>  3C6H R/W:   Pixel Mask (color look-up table destroyed on write)<br>  3C7H Read:  DAC State Register<br>  3C7H Write: Pixel Address<br>  3C8H R/W:   Pixel Address</p>
<p>Read Feature Control Register: 3CAH: All bits reserved.</p>
<p>Miscellaneous Output Register: 3CCH (R)  See port 3C2h.</p>
<p>Graphics Registers:            3CEH-3CFH:</p>
<p>Graphics Controller Registers: 3CEH:</p>
<p>This read/write register is loaded with the index to the graphic registers<br>described below:</p>
<p>Graphics Registers (R/W)       3CFH:</p>
<p>Set/Reset Register (R/W) (Index 0):</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>   3     Set/Reset Map 3<br>   2     Set/Reset Map 2<br>   1     Set/Reset Map 1<br>   0     Set/Reset Map 0</p>
<p>Enable Set/Reset Register (R/W) (Index 1):</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>   3     Enable Set/Reset Map 3<br>   2     Enable Set/Reset Map 2<br>   1     Enable Set/Reset Map 1<br>   0     Enable Set/Reset Map 0</p>
<p>Color Compare Register (R/W) (Index 2):</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>   3     Color Compare Map 3<br>   2     Color Compare Map 2<br>   1     Color Compare Map 1<br>   0     Color Compare Map 0</p>
<p>Data Rotate Register (R/W) (Index 3):</p>
<p>  Bit    Function</p>
<p>  7-5    Reserved = 0<br>  4-3    Function Select  00 Data unmodified, 01 ANDed, 10 ORed, 11 XORed<br>  2-0    Rotate Count for right-rotate (write mode 0)</p>
<p>ReadMap Select Register (R/W) (Index 4):</p>
<p>  Bit    Function</p>
<p>  7-2    Reserved = 0<br>  1-0    Map Select for read</p>
<p>Graphics Mode Register (R/W) (Index 5):</p>
<p>  Bit    Function</p>
<p>   7     Reserved = 0<br>   6     256 color mode:<br>          0=allow bit 5 to control loading of Shift registers<br>   5     Shift Register Mode:<br>          1=format serial data with even-numbered bits for even maps<br>                                    odd-numbered bits for odd maps<br>   4     Odd/Even:  1=odd/even addressing mode<br>   3     Read Type: 0=reads from memory map selected by Read Map Select Reg.<br>   2     Reserved<br>  1-0    Write Mode for memory map:<br>          00=data rotated unless Set/Reset is enabled<br>          01=from contents of system CPU latches<br>          10=map n (0-3) filled with 8 bits of data bit n<br>          11=from 8 bits in Set/Reset register for that map</p>
<p>Miscellaneous Register (R/W) (Index 6):</p>
<p>  Bit    Function</p>
<p>  7-4    Reserved = 0<br>  3-2    Memory Map: 00=A0000 for 128K bytes<br>                     01=A0000 for  64K bytes<br>                     10=B0000 for  32K bytes<br>                     11=B8000 for  32K bytes<br>   1     Odd/Even: 1=use odd/even maps for odd even addresses<br>   0     Graphics Mode: 1=graphics mode, 0=alphanumeric mode</p>
<p>Color Don’t Care Register (R/W) (Index 7):</p>
<p>   Bit   Function</p>
<p>  7-4    Reserved = 0<br>   3     Map 3 - Don’t Care (0=Don’t participate in color compare cycle)<br>   2     Map 2 - Don’t Care<br>   1     Map 1 - Don’t Care<br>   0     Map 0 - Don’t Care</p>
<p>Bit Mask Register (R/W) (Index 8):</p>
<p>  Bit    Function</p>
<p>  7-0    Mask: 0=bit n in each map to be immune to change (modes 0 and 2)</p>
<p>Ports 3F0H-3F7H: Diskette Controller Ports</p>
<p>The PC uses a NEC 765 floppy disk controller.  The PS/2 uses a 8272A<br>diskettee controller.  The functions and port assignments for the PS/2<br>and AT are made software compatible with the PC diskette controller.<br>The 765 controller uses ports 3F2H, 3F4H, and 3F5H, while the 8272 uses<br>ports 3F0H, 3F1H, 3F2H, 3F4H, 3F5H, and 3F7H.</p>
<p>Ports 3F0H, 3F1H: PS/2 Diskette Status Registers</p>
<p>On the PS/2, the ports 3F0H and 3F1H show two of three status registers<br>used in diskette operations.</p>
<p>Status Register A, at 3F0H, is a read-only register showing:</p>
<p>  Bit    Function</p>
<p>   7     Interupt pending<br>   6     -Second drive installed<br>   5     Step<br>   4     -Track 0<br>   3     Head 1 select<br>   2     -Index<br>   1     -Write protect<br>   0     Direction</p>
<p>Status Register B, at 3F1H, is a read-only register showing:</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved<br>   5     Drive select<br>   4     Write data (toggles on positive transition in WR DATA)<br>   3     Read data (toggles on positive transition in -RD DATA)<br>   2     Write enable<br>   1     Motor enable 1<br>   0     Motor enable 0</p>
<p>Ports 3F2H, 3F4H, 3F5H: PS/2 8272 Diskette Controller:</p>
<p>Digital Output Register, at 3F2H, is write-only, and used to control<br>drive motors, drive selection, and feature enable.  All bits are cleared<br>by a Reset.</p>
<p>  Bit    Function</p>
<p>  7-6    Reserved<br>   5     Motor enable 1 when select 1 is high<br>   4     Motor enable 0 when select 0 is high<br>   3     Reserved (765 enable interrupt and DMA access)<br>   2     -8272A Reset<br>   1     Reserved<br>   0     Drive select (0 = drive 0, 1 = drive 1)</p>
<p>Diskette Drive Controller Status Register, at 3F4H, is read-only, and<br>used to facilitate the transfer of data between the system<br>microprocessor and the controller.</p>
<p>  Bit    Function</p>
<p>   7     Request for master (1 = data register ready)<br>   6     Data I/O direction (1 = from controller to microprocessor)<br>   5     Non-DMA mode if 1<br>   4     Diskette controller busy if 1<br>  3-2    Reserved<br>   1     Drive 1 busy (in seek mode)<br>   0     Drive 0 busy (in seek mode)</p>
<p>Data Registers for storing data, commands, parameters, and status<br>information, are accessed from 3F5H.</p>
<p>Port 3F7H is dual purpose on the PS/2:</p>
<p>Digital Input Register at 3F7H is read-only and used to sense the state<br>of the ‘-diskette change’ signal and the ‘-high density select’ signal:</p>
<p>  Bit    Function</p>
<p>   7     Diskette change<br>  6-1    Reserved<br>   0     -High density select</p>
<p>Configuration Control Register at 3F7H is write-only and used to<br>set the transfer rate.</p>
<p>  Bit    Function<br>  7-2    Reserved<br>  1-0    DRC1, DRC0<br>          00 = 500,000-bit/sec mode<br>          01 = reserved<br>          10 = 250,000-bit/sec mode<br>          11 = reserved</p>
<p>Programming the 765 and 8272 Controllers:</p>
<p>The 765 and 8272 Diskette Controller performs fifteen operations,<br>including seek, read, and writes.  Each operation is performed in three<br>phases: the command phase, the execution phase, and the result phase.<br>The following commands are available:</p>
<p>Read Data<br>Read Deleted Data<br>Read a Track<br>Read ID<br>Write Data<br>Write Deleted Data<br>Format a Track<br>Scan Equal<br>Scan Low or Equal<br>Scan High or Equal<br>Recalibrate<br>Sense Interrupt Status<br>Specify Step and Head Load<br>Sense Drive Status<br>Seek</p>
<p>As an example, the read operation follows:</p>
<ol>
<li>Turn on diskette motor and set delay time for drive to<br>come up to speed.</li>
<li>Perform seek opertion.  Wait for completion interrupt.</li>
<li>Initialize DMA chip to move data to memory.</li>
<li>Send read instruction and wait for data-transfer-completion<br>interrupt.</li>
<li>Read status information.</li>
<li>Turn off motor.</li>
</ol>
<p>Operations are performed by sending a command string to the data port<br>(checking the bit 6 of the status register after each byte).  Interrupt<br>6 is generated by the controller after a seek operation is complete.<br>The interrupt handler simply sets bit 7 at 40:3EH, the seek status byte.<br>Poll this byte until bit 7 is set, then reset the bit and continue with<br>next sector operation, initialization of the DMA chip.</p>
<p>Ports 3220-3227, 3228-322E, 4220-4227, 4228-422E, 5220-5227, 5228-522E:</p>
<p>These are the assigned COM3-8 serial ports on the PS/2, all utilizing<br>IRQ3 interrupt line.  For programming information, see ports 2E8-2EE.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/25/build-vnc/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++是一种强类型编译器语言。虽然不像ADA那样强类型，但如果您尝试将一种类型的对象分配给另一种类型的对象（如果没有可接受的转换），则C++编译器会抱怨。显然，这要求编译器知道所有可用的类型。更具体地说，所有类都必须在编译时<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn1">知道1</a>。但有时，在运行时添加新类会非常方便。在某些应用领域，这是绝对必要的。</p>
<h2 id="一个简单的故事"><a href="#一个简单的故事" class="headerlink" title="一个简单的故事"></a>一个简单的故事</h2><p>让我们看一个简单的例子：苏珊，当地一家书店的经理，想扩展到互联网。所以她要求你为一家互联网书店写一个简单的程序。对你来说没问题。解决方案的一部分可能类似于图 1 中的类模型。<br><img src="/build-vnc/fig1.jpg" alt="Fig. 1: Simple Shop Model"><br>图 1：简单车间模型</p>
<p>C++中实现它非常简单。这是课程：<br>你的解决方案有效，苏珊很高兴，一切都很好……<br>但互联网时代，网络上发生了变化：书店取得了成功，苏珊也决定出售CD。所以你必须改变你的程序。使用面向对象，您可以非常轻松地执行此操作，并且您修改后的类模型将如图 2 所示。<br><img src="/build-vnc/fig2.jpg" alt="Fig. 2: Product Model"><br>图2：产品模型</p>
<p>您可能已经猜到了，这仅仅是个开始。一段时间后，苏珊也想卖流行音乐配件，如T恤，海报等。<br>现在很明显，每次引入新产品类别时修改程序的源代码都是不可接受的。因此，您开始考虑实际需求，并发现需要为类提供不同的接口（图 3）：用于提供 、 和 的简单接口。这是你已经拥有的。然后，您需要为常规搜索机<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn2">2</a>设置一个不同的界面，该界面必须提供以下信息：<code>Book</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Book(<span class="keyword">const</span> <span class="built_in">string</span> &amp; author_,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">string</span> &amp; title_,</span><br><span class="line">             <span class="keyword">const</span> <span class="built_in">string</span> &amp; publisher_,</span><br><span class="line">             <span class="built_in">double</span> price_,</span><br><span class="line">             <span class="built_in">double</span> weight_);</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> name;</span><br><span class="line">            name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line">            <span class="keyword">return</span> name.substr(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">double</span> <span class="title">getPrice</span>()</span>;</span><br><span class="line">        <span class="function"><span class="built_in">double</span> <span class="title">getWeight</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> author, title, publisher;</span><br><span class="line">        <span class="built_in">double</span> price, weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">Product``ShoppingCart``getName()``getPrice()``getWeight()</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的实际类是什么</li>
<li>该类具有哪些属性</li>
<li>对象的这些属性的实际值是什么。</li>
</ul>
<p>这是一个经典的反射接口，为您提供有关类和对象属性的信息。<br>但是，您还需要第三个用于产品维护的接口，该接口允许您定义新的产品类、为它们指定属性、创建这些类的实例以及设置这些实例的属性值。这样的接口被称为“元对象协议（MOP）”，并在[<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk1">1</a>]中进行了详尽的讨论。反射协议是此类 MOP 的子集。<br><img src="/build-vnc/fig3.jpg" alt="Fig. 3: A Better Model"><br>图 3：更好的模型</p>
<h2 id="C-元类"><a href="#C-元类" class="headerlink" title="C++元类"></a>C++元类</h2><p>“元对象协议”是什么意思？嗯，元信息是关于从一个超越的层次看到的其他东西的信息—— 一个元层次。因此，有关对象属性值的信息（例如 ）是对象级别的信息。但是，有关对象本身的属性、属性、结构等的信息是元信息。<br>在C++中，此信息在对象的类定义中捕获，因此该类是元对象。在C++中，您在课堂上拥有MOP的所有功能 - 这是在开发时。但是该级别在运行时不可用：您不能像对象一样操作类，也不能在运行时添加新类。MOP的想法是折叠元级别（类）和对象级别（对象）;即使类定义成为普通对象，并且对象属性是可以在运行时操作的类定义的正常属性值。<br>虽然像CLOS或Smalltalk这样的语言直接提供了这种组合级别，但C++强类型编译器语言没有这样的功能。那么，你能做些什么呢？典型的解决方案是自己提供MOP，例如在[2]或[<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk3">3</a>]中提出的。<code>someBook.author</code></p>
<h3 id="澳门币概览"><a href="#澳门币概览" class="headerlink" title="澳门币概览"></a>澳门币概览</h3><p>为简单起见，我们现在忽略方法，因此我们的 MOP 必须提供：</p>
<ul>
<li>新类的定义</li>
<li>向类添加属性</li>
<li>查询类的属性</li>
<li>创建对象</li>
<li>查询对象的类</li>
<li>设置对象的属性值</li>
<li>查询对象的属性值</li>
<li>删除对象</li>
</ul>
<p>如果你使用OO设计的旧规则，你把上述要求的所有名词都拿出来，从中生成类。当您考虑“属性”和“值”时，您必须确定它们是否被键入。由于键入了基础语言C++，因此应在设计中反映这一点。<br>另一个问题是关于继承支持。对于我们关于互联网商店和产品层次结构的示例，这可能非常有用。因此，第一类模型如图 4 所示。<br><img src="/build-vnc/fig4.jpg" alt="Fig. 4: MOP Class Model"><br>图 4： MOP 类模型</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>虽然自上而下地进行一般概述很有用，但从细节的简单基本内容开始会更容易。因此，我们首先看一下 .<br>主要目的是区分不同类型的s。为此，一个简单的就足够了。但是类型的想法是为不同的s提供不同的种类，所以应该创建新的s。因此，我们将类放入内部，提供方法，并获取图 4 中所示的接口。<br>现在实施。虽然我们现在不仔细研究，但如果我们有不同类型的值，我们可能需要一些基类。让我们将其称为 “”，并且只能返回指向 的指针。<br>现在我们知道要创造什么，但如何创造呢？虽然有几种模式可以实现多态创建[<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk4">4</a>]，但就我们的目的而言，最简单的模式可能是原型，它可以通过简单的<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn3">3</a>轻松实现。<br>现在，我们已拥有实现整个类的所有内容：<code>Type``Type``Attribute``enum``Values``Type``Type``Value``enum``Type``newValue()``Value``BaseValue``newValue()``BaseValue``static vector</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TypeT</span> &#123;stringT, intT, doubleT, unknownT&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Type</span><span class="params">(TypeT typeId_)</span> : typeId(typeId_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseValue * <span class="title">newValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prototypes[typeId]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TypeT <span class="title">getType</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        prototypes[stringT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;string&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        prototypes[intT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">        prototypes[doubleT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TypeT typeId;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> vector&lt;BaseValue *&gt; prototypes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;BaseValue *&gt; <span class="title">Type::prototypes</span><span class="params">(Type::unknownT)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>由于我们决定通过 创建新的 s，因此只包含名称和类型，因此下面是其实现：<code>Value``Type``Attribute</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Attribute</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Attribute(<span class="params">const</span> <span class="params">string</span> &amp; <span class="params">name_</span>, Type::TypeT <span class="params">typeId</span>)</span></span><br><span class="line">     : name(name_), <span class="keyword">type</span><span class="constructor">_(<span class="params">typeId</span>)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    const <span class="built_in">string</span> &amp; get<span class="constructor">Name()</span> const</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    Type get<span class="constructor">Type()</span> const</span><br><span class="line">    &#123;</span><br><span class="line">        return type_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    Type type_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>现在，我们可以通过查看自身来完成模型的类（元）级别。由于多重继承可能不是我们的目的的问题，因此我们只有一个指向基类的指针（可以是0）。更重要的问题是属性列表：它应该只包含为此类定义的属性，还是应该包括所有继承的属性？虽然对于实际的对象值访问，完整列表更有用（而且速度更快），但对于类维护，了解在哪个类中定义了哪个属性可能很重要。所以我们只保留两者。对于完整列表，顺序可能很重要：应该先是自己的属性还是继承的属性？在大多数插图中，继承的属性排在第一位，因此我们也保持此顺序。<br>如果属性的名称与继承属性的名称相同，会发生什么情况？由于C++允许它，我们也可以允许它（为我们节省了一些额外的检查工作），但是在这种情况下，我们必须保证在按名称查找属性时，我们会得到派生最多的属性。所以，必须做一个反向搜索。我们该从什么回来？STL 方法是返回迭代器，但对于具有 GUI 的应用程序（创建新对象并根据选择列表为其属性赋值），对属性进行基于索引的访问将更合适。因此，返回一个索引并获取一个索引并返回一个 .因此，列表必须是索引容器，因此我们为它们选择 s。<br>的一个主要目的是从中创建 s，因此它有一个返回指向 的指针的方法。我们是否需要保留一个引用所有已创建对象的存储库？对于完整的反射接口，我们应该这样做。但对于实际应用程序，这几乎从来都没用，因为同一类的对象是为完全不同的目的而创建的。但是，我们是否需要存储库供内部使用？这取决于我们在创建对象后要对对象执行的操作。这直接导致了另一个重要的决定：如果我们向类添加新属性，我们如何处理已经存在的对象？一种选择是将此属性添加到所有现有对象并为其分配默认值。另一种选择是保留这些现有对象，并仅将 new 属性添加到新对象。这导致同一类的对象同时具有不同的结构，然后我们必须向对象添加一些版本信息。但是还有第三种选择：一旦创建了类的实例，就禁止修改该类定义。这是最简单的选项，因此我们将其用于MOP并添加标志 。有了这个标志，我们可以跳过对象存储库。<br>最后一个设计问题是何时添加属性：在类定义的创建时（通过构造函数）还是稍后（使用成员函数）？对于不同的应用程序，这两个选项可能都很有用，因此我们将提供两个构造函数和 。<br>现在，您可以实现此 <a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn4">4</a>：<code>Class``findAttribute()``findAttribute()``findAttribute()``getAttribute()``Attribute``Attribute``vector``Class``Object``newObject()``Object``definitionFix``addAttribute()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDef</span></span><br><span class="line">&#123;        <span class="comment">//typedefs Container, Iterator for attributes</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> * base, <span class="type">const</span> string &amp; name_)</span><br><span class="line">     : <span class="built_in">baseClass</span>(base), <span class="built_in">name</span>(name_),</span><br><span class="line">       <span class="built_in">definitionFix</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">baseInit</span>();</span><br><span class="line">        effectiveAttributes.<span class="built_in">insert</span>(effectiveAttributes.<span class="built_in">end</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">begin</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> iterator&gt;</span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> * base, <span class="type">const</span> string &amp; name_,</span><br><span class="line">             iterator attribBegin, iterator attribEnd)</span><br><span class="line">     : <span class="built_in">baseClass</span>(base), <span class="built_in">name</span>(name_),</span><br><span class="line">       <span class="built_in">ownAttributes</span>(attribBegin, attribEnd),</span><br><span class="line">       <span class="built_in">definitionFix</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">baseInit</span>();</span><br><span class="line">        effectiveAttributes.<span class="built_in">insert</span>(effectiveAttributes.<span class="built_in">end</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">begin</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Object * <span class="title">newObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        definitionFix = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AttrIterator <span class="title">attribBegin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">AttrIterator <span class="title">attribEnd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Attribute <span class="type">const</span> &amp; <span class="title">getAttribute</span><span class="params">(<span class="type">size_t</span> idx)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAttribute</span><span class="params">(<span class="type">const</span> Attribute &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getAttributeCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">findAttribute</span><span class="params">(string <span class="type">const</span> &amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this does a reverse search to find the most derived</span></span><br><span class="line">        AttributeContainer::const_reverse_iterator i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = effectiveAttributes.<span class="built_in">rbegin</span>();</span><br><span class="line">             i != effectiveAttributes.<span class="built_in">rend</span>();</span><br><span class="line">             ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;<span class="built_in">getName</span>() == name)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">distance</span>(i, effectiveAttributes.<span class="built_in">rend</span>()) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getAttributeCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (baseClass)</span><br><span class="line">        &#123;</span><br><span class="line">            baseClass-&gt;definitionFix = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">copy</span>(baseClass-&gt;<span class="built_in">attribBegin</span>(), baseClass-&gt;<span class="built_in">attribEnd</span>(),</span><br><span class="line">                 <span class="built_in">back_inserter</span>&lt;AttributeContainer&gt;(effectiveAttributes));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassDef <span class="type">const</span> * <span class="type">const</span> baseClass;</span><br><span class="line">    string name;</span><br><span class="line">    AttributeContainer ownAttributes, effectiveAttributes;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> definitionFix;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><img src="/build-vnc/fig5.jpg" alt="Fig. 5: Value Model"><br>图5：价值模型<br>在设计之前，我们必须考虑。我们需要一个通用的界面来管理它们，我们已经称之为 。但是我们需要什么接口呢？整个想法是存储值，因此我们需要一个函数。什么参数？我们唯一拥有的是 ，所以这就是参数类型。按值、按引用或按指针传递？绝对不是按值，因为只是一个接口。另一方面，您传递的是一个值，因此传递的参数应按值传递，以便传递临时参数。因此，一种选择是通过 const 引用传递。但是，尽管这有助于解决手头的问题，但它并不能解决根本问题：你应该有一个值，但你所拥有的只是一个多态接口。这里真正的解决方案是pimpl成语，也称为柴郡猫，信封/信件，或更一般的手柄/身体。因此，我们添加一个句柄类，为其命名，稍后再看一遍。目前，我们仍然处于 .<br>我们现在有，那又如何呢？的返回类型是 ，实现将如下所示：<br>但是我们可以直接执行，因此没有多大意义。<br>我们还需要哪些其他功能？必须复制值，因此我们添加了 .<br>这就是我们真正需要的值，但我们添加是为了方便<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn5">5</a>。<code>Object``Value``BaseValue``Value``set()``BaseValue``BaseValue``Value``BaseValue``set(Value)``get()``get()``Value</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">Value <span class="title">BaseValue::get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// calls Value(BaseValue const &amp;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">get</span>()``BaseValue``<span class="built_in">clone</span>()``<span class="built_in">asString</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BaseValue</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">BaseValue</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> BaseValue * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// fromString()</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set</span><span class="params">(Value <span class="type">const</span> &amp; v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// no get()!</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// Type info</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="RealValue"><a href="#RealValue" class="headerlink" title="RealValue"></a>RealValue</h3><p>现在，由于我们有了接口，那么实现呢？我们需要 、 . … 的值。并且一个值必须包含 一个 ， 一个值 a ，等等。这看起来像是模板的机会。因此，让我们定义，从中派生它，实现继承的接口，我们几乎完成了。但是，由于只是一个带有一些附加功能的包装器，但本质上仍然是一个，我们应该通过提供转换构造函数和转换运算符来提供双向转换。<br>注意：由于我们在两个方向上都有转换，我们可以使用类似：<br>几乎：以下不起作用：<br>原因是编译器只应用一个用户定义的转换，但对于字符串文本，您需要两个：from to ，和 from to to 。如果要在 MOP 外部使用，则应定义一个特化：注意：<br>实际上，从 派生并不是很干净，但只要您不删除指向 的指针，它就会起作用。<code>int``double``string``int``int``double``double``RealValue``BaseValue``RealValue``T``T</code></p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;typename PlainT&gt;</span><br><span class="line">    <span class="keyword">class</span> RealValue : <span class="keyword">public</span> BaseValue</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        RealValue(PlainT v)</span><br><span class="line">         : val(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        RealValue * clone() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RealValue(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> asString() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            ostringstream os;</span><br><span class="line">            os &lt;&lt; val;</span><br><span class="line">            <span class="keyword">return</span> os.str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operator PlainT() <span class="keyword">const</span> <span class="comment">// conversion to plain type</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RealValue&lt;PlainT&gt;::set(Value <span class="keyword">const</span> &amp; v)</span><br><span class="line">        &#123;</span><br><span class="line">            val = v.get&lt;PlainT&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        PlainT val;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">RealValue<span class="string">``</span>RealValue<span class="string">``</span>T</span><br><span class="line">    RealValue&lt;<span class="keyword">int</span>&gt; i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    RealValue&lt;<span class="built_in">double</span>&gt; d = i + <span class="number">5.2</span> / (i*<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    RealValue&lt;<span class="built_in">string</span>&gt; name, author = <span class="string">&quot;Bjarne&quot;</span>, title = <span class="string">&quot;The C++ PL&quot;</span>;</span><br><span class="line">    name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">char</span> <span class="keyword">const</span> *<span class="string">``</span><span class="built_in">string</span><span class="string">``</span><span class="built_in">string</span><span class="string">``</span>RealValue<span class="string">``</span>RealValue</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">class</span> RealValue&lt;<span class="built_in">string</span>&gt; : <span class="keyword">public</span> BaseValue, <span class="keyword">public</span> <span class="built_in">string</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        RealValue(<span class="built_in">string</span> <span class="keyword">const</span> &amp; s) : <span class="built_in">string</span>(s) &#123;&#125;</span><br><span class="line">        RealValue(<span class="built_in">char</span> <span class="keyword">const</span> * s) : <span class="built_in">string</span>(s) &#123;&#125;</span><br><span class="line">        RealValue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        RealValue * clone() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RealValue(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> asString() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> static_cast&lt;<span class="built_in">string</span>&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// no operator string(), conversion to base automatically</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> set(Value <span class="keyword">const</span> &amp; v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>::operator=(v.get&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">RealValue<span class="string">``</span>std::<span class="built_in">string</span><span class="string">``</span>RealValue<span class="string">``</span><span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<h3 id="值句柄"><a href="#值句柄" class="headerlink" title="值句柄"></a>值句柄</h3><p>现在回到句柄类。作为句柄类，它包含其主体并照顾它。其主要工作是采用/创建和删除其正文。它镜像正文的界面并转发所有消息。但它也应该是一个真正的值类，从而提供默认和复制构造函数和赋值。但是如何实现默认构造函数呢？由于我们不知道要创建什么类型，因此我们必须创建一个没有正文的空句柄，并在转发之前检查我们是否真的有要转发的内容。赋值本质上是 ，因此我们跳过 .<br>现在让我们回到.当然，返回或没有意义。但是，返回甚至包装的基础值呢？这将是非常有用的，但为此，我们必须告诉我们我们想要的返回类型。因此，成为成员模板，因此可以返回 .<code>Value``set()``set()``get()``Value``BaseValue``RealValue``get()``get()``RealValue&lt;&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>        <span class="comment">// Value handle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Value</span>(BaseValue <span class="type">const</span> &amp; bv)</span><br><span class="line">     : <span class="built_in">v</span>(bv.<span class="built_in">clone</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Value</span>(Value <span class="type">const</span> &amp; rhs)</span><br><span class="line">     : <span class="built_in">v</span>(rhs.v ? rhs.v-&gt;<span class="built_in">clone</span>() : <span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Value</span><span class="params">(BaseValue * bv = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">     : v(bv)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Value</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Value &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Value &amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this is not a typical pimpl assignment, but a set()</span></span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rhs.v)</span><br><span class="line">            &#123; <span class="comment">// fine, all v&#x27;s exist</span></span><br><span class="line">                v-&gt;<span class="built_in">set</span>(rhs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; <span class="comment">// the other v doesn&#x27;t exist, so we must delete our own :-(</span></span><br><span class="line">                BaseValue * old = v;</span><br><span class="line">                v = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">delete</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// we don&#x27;t have a v, so just copy the other</span></span><br><span class="line">            v = (rhs.v ? rhs.v-&gt;<span class="built_in">clone</span>() : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PlainT&gt;</span><br><span class="line">    <span class="function">PlainT <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            RealValue&lt;PlainT&gt; <span class="type">const</span> &amp; rv</span><br><span class="line">                = <span class="keyword">dynamic_cast</span>&lt;RealValue&lt;PlainT&gt; <span class="type">const</span> &amp;&gt;(*v);</span><br><span class="line">            <span class="keyword">return</span> rv;        <span class="comment">// uses conversion operator</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">PlainT</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;<span class="built_in">asString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BaseValue * v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Finally we come to . Now, as we have everything else, an is mainly a container for its attribute values. To ease implementation, we will structurally mirror the attribute container in the class definition, so we use a . As we have so much effort invested in our handle, it would make sense to store that in the . But for future extensions it will be easier to have the pointers directly available.<br>The constructor will create the values through the types of the attributes, so the only constructor takes a .<br>To set and get the values for the attributes, we provide two options: to specify the attribute by name and also by index.<br>For reflection purposes (as well as for internal implementation) we need a pointer to the class definition, but then we have it all:<br>Now the MOP is complete. Let’s use it:<br>Creating the class:<br>Adding attributes:<br>Creating the class with an attribute list:<br>Creating an object:<code>Object``Object``vector``Value``vector``BaseValue``ClassDef*</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Object</span><span class="params">(ClassDef <span class="type">const</span> * class_)</span></span></span><br><span class="line"><span class="function">         : myClass(class_), values(class_-&gt;getAttributeCount())</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">            <span class="built_in">buildValueList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ClassDef <span class="type">const</span> &amp; <span class="title">instanceOf</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *myClass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Value <span class="title">getValue</span><span class="params">(<span class="type">size_t</span> attribIdx)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *values[attribIdx]; <span class="comment">// calls Value(BaseValue &amp;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Value <span class="title">getValue</span><span class="params">(string <span class="type">const</span> &amp; attribName)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> idx = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">findAttribute</span>(attribName);</span><br><span class="line">            <span class="comment">// should check for not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getValue</span>(idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">size_t</span> idx, Value <span class="type">const</span> &amp; v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            values[idx]-&gt;<span class="built_in">set</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(string <span class="type">const</span> &amp; attribName, Value <span class="type">const</span> &amp;v)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> idx = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">findAttribute</span>(attribName);</span><br><span class="line">            <span class="comment">// should check for not found</span></span><br><span class="line">            <span class="built_in">setValue</span>(idx, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> vector&lt;BaseValue *&gt; ValueContainer;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buildValueList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ClassDef::AttrIterator a;</span><br><span class="line">            ValueContainer::iterator i = values.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (a = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribBegin</span>();</span><br><span class="line">                 a != <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribEnd</span>();</span><br><span class="line">                 ++a, ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                *i = a-&gt;<span class="built_in">getType</span>().<span class="built_in">newValue</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ClassDef <span class="type">const</span> * <span class="type">const</span> myClass;</span><br><span class="line">        ValueContainer values;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">Product</span><br><span class="line">    ClassDef * product</span><br><span class="line">         = <span class="keyword">new</span> <span class="built_in">ClassDef</span>(<span class="number">0</span>, <span class="comment">// no base class for Product</span></span><br><span class="line">                        <span class="string">&quot;Product&quot;</span>); <span class="comment">// name of class</span></span><br><span class="line">    </span><br><span class="line">    product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Product Number&quot;</span>, Type::intT));</span><br><span class="line">    product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Name&quot;</span>, Type::stringT));</span><br><span class="line">    product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>, Type::doubleT));</span><br><span class="line">    product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Weight&quot;</span>, Type::doubleT));</span><br><span class="line">    </span><br><span class="line">Book</span><br><span class="line">    list&lt;Attribute&gt; attrL;</span><br><span class="line">    attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Author&quot;</span>, Type::stringT));</span><br><span class="line">    attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Title&quot;</span>, Type::stringT));</span><br><span class="line">    attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;ISBN&quot;</span>, Type::intT));</span><br><span class="line"></span><br><span class="line">    ClassDef * book</span><br><span class="line">     = <span class="keyword">new</span> <span class="built_in">ClassDef</span>(product, <span class="comment">// base class</span></span><br><span class="line">                    <span class="string">&quot;Book&quot;</span>,</span><br><span class="line">                    attrL.<span class="built_in">begin</span>(), attrL.<span class="built_in">end</span>());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="class">Object</span></span> * <span class="function"><span class="title">bscpp</span>(<span class="variable">book</span>-&gt;<span class="title">newObject</span>());</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h4 id="Setting-the-values-for-the-objects"><a href="#Setting-the-values-for-the-objects" class="headerlink" title="Setting the values for the objects:"></a>Setting the values for the objects:</h4><p>Set an int value by index (don’t forget that index 0 is ):<br>Same for a string value:<br>Better way: set value by name this gives the most derived attribute:<code>ProductNo</code></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">bscpp-&gt;setValue(<span class="number">0</span>, RealValue&lt;int&gt;(<span class="number">12345</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">bscpp-&gt;setValue(<span class="number">4</span>, RealValue&lt;string&gt;(<span class="string">&quot;Bjarne Stroustrup&quot;</span>))<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">bscpp-&gt;setValue(<span class="string">&quot;Title&quot;</span>,</span><br><span class="line">                RealValue&lt;string&gt;(<span class="string">&quot;The C++ Programming Language&quot;</span>))<span class="comment">;</span></span><br><span class="line">bscpp-&gt;setValue(<span class="string">&quot;Weight&quot;</span>, Value&lt;double&gt;(<span class="number">370</span>))<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Getting-the-values"><a href="#Getting-the-values" class="headerlink" title="Getting the values:"></a>Getting the values:</h4><p>Display a book:<br>and we get:<br>So, our MOP is complete. For our sample application, you have to add a class repository, some nice GUI to define classes and objects, creating the index for the search machine, provide an interface for , but then you’re done, and Susan is happy as she now can create her own new product categories at runtime.</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line">        ClassDef::AttrIterator a;</span><br><span class="line">        <span class="attribute">size_t idx;</span></span><br><span class="line"><span class="attribute">        for (a = book-&gt;attribBegin(), idx = 0;</span></span><br><span class="line"><span class="attribute">             a != book-&gt;attribEnd();</span></span><br><span class="line"><span class="attribute">             ++a, ++idx)</span></span><br><span class="line"><span class="attribute">        &#123;</span></span><br><span class="line"><span class="attribute">            cout &lt;&lt; a-&gt;getName() &lt;&lt; &quot;</span><span class="punctuation">:</span> <span class="string">&quot;</span></span><br><span class="line">                 <span class="attribute">&lt;&lt; bscpp-&gt;getValue(idx).asString() &lt;&lt; endl;</span></span><br><span class="line"><span class="attribute">        &#125;</span></span><br><span class="line"><span class="attribute">    </span></span><br><span class="line"><span class="attribute">    Product Number</span><span class="punctuation">:</span> <span class="string">12345</span></span><br><span class="line">    <span class="attribute">Name</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">Price</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">Weight</span><span class="punctuation">:</span> <span class="string">370</span></span><br><span class="line">    <span class="attribute">Author</span><span class="punctuation">:</span> <span class="string">Bjarne Stroustrup</span></span><br><span class="line">    <span class="attribute">Title</span><span class="punctuation">:</span> <span class="string">The C++ Programming Language</span></span><br><span class="line">    <span class="attribute">ISBN</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">    </span></span><br><span class="line">ShoppingCart</span><br></pre></td></tr></table></figure>

<h2 id="Reflection-for-existing-C-classes"><a href="#Reflection-for-existing-C-classes" class="headerlink" title="Reflection for existing C++ classes"></a>Reflection for existing C++ classes</h2><p>If you provide the interface for the in our example, you’ll find that it isn’t so easy. If all classes are dynamic classes, all access must go through the MOP:<br>A for :<br>For a lot of applications, it would be useful to provide some classes of a hierarchy as C++ classes, e.g. , but still let the user add classes of the same hierarchy at runtime, e.g. . So, let’s look at this. If we want access through our MOP to C++ classes, we need a to which we can give the attribute we want to access at runtime. So, here it is:<br>The magic lies in : This is the pointer-to-member selector of C++.<code>ShoppingCart``getName()``Book</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> <span class="title function_">bookGetName</span>(<span class="params"><span class="built_in">Object</span> <span class="keyword">const</span> * book</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (book-&gt;<span class="title function_">instanceOf</span>().<span class="title function_">getName</span>() != <span class="string">&quot;Book&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* throw some exception */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="comment">//  name = book-&gt;author + &quot;: &quot; + book-&gt;title;  it was so easy...</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> author = book-&gt;<span class="title function_">getValue</span>(<span class="string">&quot;Author&quot;</span>).<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">string</span> title = book-&gt;<span class="title function_">getValue</span>(<span class="string">&quot;Title&quot;</span>).<span class="property">get</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Product</span><span class="string">``</span><span class="title class_">TShirt</span><span class="string">``</span><span class="title function_">getValue</span>()</span><br><span class="line">    <span class="title class_">Value</span> <span class="title function_">getValue</span>(<span class="params"><span class="built_in">Object</span> *o, MemberPointer mp</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o-&gt;*mp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;-&gt;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Pointer-to-member"><a href="#Pointer-to-member" class="headerlink" title="Pointer to member"></a>Pointer to member</h3><p>You can imaging a pointer-to-member in C++ as an offset<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn6">6</a> from the base address of an object to a specific member. If you apply that offset to such a base address, you get a reference to the member (Fig. 6). But as a pointer-to-member is a normal data type in C++, you can store them in containers, pass them to functions, etc. Thus, you can write the function above, building the fundamental base for our combination of C++-classes and runtime-classes.<br><img src="/build-vnc/fig6.jpg" alt="Fig. 6: Pointer to Member"><br>Fig. 6: Pointer to Member<br>Let’s look at some details of pointer-to-members. As an example, we use the following class:<br>A pointer-to-member is a type that is derived from two other types: The type of the base object ( in our example) and the type of the member (). The type decorator for a pointer-to-member is ‘’, so let’s define two variables with initialization:</p>
<p>The pointer-to-member selector comes in two variations: as ‘’ you can apply it to references of the class and as ‘’ it takes a pointer. It is a binary operand, as left operand it takes a reference (or pointer) to an object and as right operand a pointer-to-member. So, with the above definitions, you can do things like<br>Of course, as is a private member of , the assignment of the pointer-to-member must be at the scope of that class. But the pointer-to-members themselves can be used even if you don’t have access privileges to the members (as long as you have access to the pointer-to-member).</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> Product</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        RealValue&lt;<span class="built_in">double</span>&gt; price;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> Book : <span class="keyword">public</span> Product</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealValue&lt;<span class="built_in">string</span>&gt; author, title;</span><br><span class="line">        RealValue&lt;<span class="built_in">double</span>&gt; weight;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Book b, *bp;</span><br><span class="line">    </span><br><span class="line">Book<span class="string">``</span>RealValue&lt;&gt;<span class="string">``</span>::*<span class="string">``</span>RealValue Book::* bookStringMemPtr = &amp;Book::author;<span class="string">``</span>RealValue Book::* bookDoubleMemPtr = &amp;Book::weight;<span class="string">``</span>.*<span class="string">``</span>-&gt;*</span><br><span class="line">    b.*bookStringMemPtr = <span class="string">&quot;Bjarne Stroustrup&quot;</span>; <span class="comment">// assigns b.author</span></span><br><span class="line"></span><br><span class="line">    bookStringMemPtr = &amp;Book::title;</span><br><span class="line"></span><br><span class="line">    bp-&gt;*bookStringMemPtr = <span class="string">&quot;The C++ Programming Language&quot;</span>; <span class="comment">// assigns b.author</span></span><br><span class="line">    </span><br><span class="line">title<span class="string">``</span>Book</span><br></pre></td></tr></table></figure>

<h3 id="pointer-to-member-Types"><a href="#pointer-to-member-Types" class="headerlink" title="pointer-to-member Types"></a>pointer-to-member Types</h3><p>A word about the types: , , and are different types. But are there conversions? The C++ standard provides a conversion from a pointer-to-member of a base class to a pointer-to-member of a derived class. That makes sense: You can apply an offset to a member of a base class to the base address of a derived object as well, as the base is a part of the derived object<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn7">7</a>. So you can assign<br>as the is part of each instance.<br>The other way around it obviously doesn’t work, you couldn’t initialize<br>as is not a member of each instance of type .<br>But the standard does not provide a conversion from to , though it would be save: If the result type of the pointer-to-member selector is a reference to a derived class, it can be safely converted to a reference of a respective base class, so it would also be safe to let the compiler do the conversion automatically and therefore also convert the pointer-to-members themselves. As already mentioned, the standard doesn’t provide (implicit) and even doesn’t allow (explicit through ) that conversion, probably because the committee didn’t see any use for pointer-to-data-members at all (see [<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk5">5</a>]), and for pointer-to-member-functions that conversion really doesn’t make sense.<br>The problem for us is: we need that conversion. We want to keep pointer-to-members to all members of a class in one common container, but what could be the type of that container’s elements? One option would be to force the conversion through a , but the only thing you can safely do with a ed thing is to it back, and for that you have to store the original type as well. So we use another option: we just define the conversion! But as C++ doesn’t allow you to define your own conversions to compiler-provided types (and in this sense the pointer-to-members are compiler defined, though the involved single types like or are user-defined), we have to define wrapper classes around them.<br>Here’s the implementation:<br>Some notes to the code: is used for the class to which a pointer to member is applied (e.g. ), is the result type to which a pointer-to-member points (), and is the base class of (). is the common base class as we need it (e.g. , which stands for ), hold an actual C++ pointer-to-member (), and is a handle class around to store them in a container. Here, the actual access function is the member function. If you want, you can add a global operator ‘’ (as template function), but you can’t provide the operator by a member function (as the left operand is not the class instance), and you can’t overload ‘’ (this is one of the few non-overloadable operators).<br>The constructor is a member template with two template parameters: a and the . The second one is clear as it defines the actual to be constructed, but the is not so obvious. If we omit the , so only having<br>and then we try to create a<br>some compilers give an error, as they cannot fiddle out the correct conversion. This would be to convert to , which should be done automatically, and then to instantiate ‘s constructor with as .<br>One way to solve this is to explicitly cast the pointer-to-member: but that’s quite a lot to type. It’s actually much easier to move that explicit conversion into the constructor itself and just provide an additional template parameter, as shown in the implementation above. The compiler checks the conversion anyway, so you will get a compile time error if that conversion is not allowed (e.g. if you try to convert a to .<code>RealValue Book::*``RealValue Product::*``BaseValue Product::*``bookDoubleMemPtr = &amp;Product::price;``price``Book``RealValue Product::* &amp;Book::author;``author``Product``RealValue Book::*``BaseValue Book::*``static_cast``reinterpret_cast``reinterpret_cast``reinterpret_cast``Book``BaseValue</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemPtrBase</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">MemPtrBase</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">MemPtrBase</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">MemPtrBase</span>(MemPtrBase <span class="type">const</span> &amp;);</span><br><span class="line">        MemPtrBase &amp; <span class="keyword">operator</span>=(MemPtrBase <span class="type">const</span> &amp;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType, <span class="keyword">typename</span> TargetType&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TypedMemPtr</span> : <span class="keyword">public</span> MemPtrBase&lt;BaseType, BaseTargetType&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TypedMemPtr</span>(TargetType BaseType::* ptr)</span><br><span class="line">         : <span class="built_in">p</span>(ptr)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj.*p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj.*p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TargetType BaseType::* p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemPtr</span> <span class="comment">// this is a handle only</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType2, <span class="keyword">typename</span> TargetType&gt;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">MemPtr</span><span class="params">(TargetType BaseType2::* ptr)</span></span></span><br><span class="line"><span class="function">         : p(new TypedMemPtr&lt;BaseType, BaseTargetType,</span></span><br><span class="line"><span class="function">            TargetType&gt;(static_cast&lt;TargetType BaseType::*&gt;(ptr)))</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">MemPtr</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;<span class="built_in">value</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;<span class="built_in">value</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MemPtrBase&lt;BaseType, BaseTargetType&gt; * p;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">BaseType``Book``TargetType``RealValue``BaseTargetType``TargetType``BaseValue``MemPtrBase&lt;&gt;``MemPtrBase``BaseValue Book::*``TypedMemPtr&lt;&gt;``TypedMemPtr &gt;``MemPtr&lt;&gt;``MemPtrBase&lt;&gt;``<span class="built_in">value</span>()``-&gt;*``.*``MemPtr``BaseType2``TargetType``TypedMemPtr``BaseType2``BaseType2</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MemPtr</span> <span class="comment">// this is a handle only</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetType&gt;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">MemPtr</span><span class="params">(TargetType BaseType::* ptr)</span></span></span><br><span class="line"><span class="function">         : p(new TypedMemPtr&lt;BaseType, BaseTargetType, TargetType&gt;(ptr))</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MemPtr&lt;Book, BaseValue&gt; <span class="title">mp2</span><span class="params">(&amp;Product::price)</span></span>;</span><br><span class="line">    </span><br><span class="line">RealValue Product::*``RealValue Book::*``MemPtr``RealValue``<span class="function">TargetType</span></span><br><span class="line"><span class="function">    MemPtr&lt;Book, BaseValue&gt;</span></span><br><span class="line"><span class="function">        <span class="title">mp2</span><span class="params">(<span class="keyword">static_cast</span>&lt;RealValue&lt;<span class="type">double</span>&gt; Book::*&gt;(&amp;Product::price))</span></span>;</span><br><span class="line">    </span><br><span class="line">RealValue Book::*``RealValue Cd::*</span><br></pre></td></tr></table></figure>

<h3 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h3><p>s 允许您访问普通C++对象的属性值。这对MOP的一部分有所帮助。但是属性本身呢？编译器具有必要的知识，但不幸的是，没有标准方法可以在运行时访问这些知识。因此，我们必须提供它并为其定义一个接口。为了允许与我们现有的顺利集成，我们提供了一个迭代器作为接口。现在，我们手动提供有关属性的信息，但在下面的文章中，我们将探讨如何使用预处理器。<br>因此，对于我们的类，我们提供以下函数：<br>请注意和之间的区别：前者仅提供有关其自身属性的信息，而后者还提供对基类成员的访问。这种分离是有道理的：虽然在对象级别上所有数据成员都构建一个对象，但在类级别上，基类是一个不同的实体，也应该作为元对象协议的公共基类使用。但是这种分离会产生后果：我们不能从MOP类派生C++类（但这绝对不是真正的限制），并且C++基类也必须让MOP知道（但这无论如何都很有用）。<br>我们没有提供有关基类信息的函数，因为如上所述，in 也必须成为一个实例。基类C++对于我们的应用程序没有多大用处。<br>使用这些函数，我们可以从C++类构建一个;这很容易，我们甚至可以为此提供一个帮助程序函数：<br>现在，我们可以为它们构建我们的s并从中创建实例：<br>但是停止 - 虽然这有效，但这不是我们想要的：现在，实例不是真正的C++对象，而是MOP对象，所有访问仍然必须通过MOP。<code>MemPtr``ClassDef``Attribute``Book</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> <span class="title class_">Product</span></span><br><span class="line">    &#123;</span><br><span class="line">        typedef <span class="title class_">MemPtr</span>&lt;<span class="title class_">Book</span>, <span class="title class_">FinalValue</span>&gt; <span class="title class_">MemberPtr</span>;</span><br><span class="line">    <span class="attr">public</span>:</span><br><span class="line">        <span class="comment">// as before</span></span><br><span class="line">        <span class="keyword">static</span> size_t <span class="title function_">ownAttribCount</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="title class_">Attribute</span> * <span class="title function_">ownAttribBegin</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="title class_">Attribute</span> a[]</span><br><span class="line">                = &#123;<span class="title class_">Attribute</span>(<span class="string">&quot;Author&quot;</span>, <span class="title class_">Type</span>::stringT),</span><br><span class="line">                   <span class="title class_">Attribute</span>(<span class="string">&quot;Title&quot;</span>, <span class="title class_">Type</span>::stringT),</span><br><span class="line">                   <span class="title class_">Attribute</span>(<span class="string">&quot;Publisher&quot;</span>, <span class="title class_">Type</span>::stringT),</span><br><span class="line">                   <span class="title class_">Attribute</span>(<span class="string">&quot;Price&quot;</span>, <span class="title class_">Type</span>::doubleT),</span><br><span class="line">                   <span class="title class_">Attribute</span>(<span class="string">&quot;Weight&quot;</span>, <span class="title class_">Type</span>::doubleT)</span><br><span class="line">                  &#125;;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="title class_">Attribute</span> * <span class="title function_">ownAttribEnd</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">ownAttribBegin</span>() + <span class="title function_">ownAttribCount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="title class_">MemberPtr</span> * <span class="title function_">memberBegin</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="title class_">MemberPtr</span> m[]</span><br><span class="line">                = &#123;<span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::productNo),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Product</span>::weight),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::author),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::title),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::publisher),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::price),</span><br><span class="line">                   <span class="title class_">MemberPtr</span>(&amp;<span class="title class_">Book</span>::weight)</span><br><span class="line">                  &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="title class_">MemberPtr</span> * <span class="title function_">memberEnd</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">memberBegin</span>() + <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">private</span>:</span><br><span class="line">        <span class="title class_">RealValue</span>&lt;<span class="built_in">string</span>&gt; author, title, publisher;</span><br><span class="line">        <span class="title class_">RealValue</span>&lt;double&gt; price, weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="title function_">ownAttribBegin</span>()<span class="string">``</span><span class="title function_">memberBegin</span>()<span class="string">``</span>baseClass<span class="string">``</span><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">ClassDef</span></span><br><span class="line">    template &lt;typename <span class="title class_">CppClass</span>&gt;</span><br><span class="line">    <span class="title class_">ClassDef</span> <span class="title function_">makeClass</span>(<span class="params">ClassDef <span class="keyword">const</span> * base, <span class="built_in">string</span> <span class="keyword">const</span> &amp; name</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ClassDef</span>(base, name,</span><br><span class="line">                        <span class="title class_">CppClass</span>::<span class="title function_">ownAttribBegin</span>(), <span class="title class_">CppClass</span>::<span class="title function_">ownAttribEnd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">Product</span><span class="string">``</span><span class="title class_">Book</span></span><br><span class="line">    <span class="title class_">ClassDef</span> <span class="title function_">base</span>(makeClass&lt;<span class="title class_">DynaProduct</span>&gt;(<span class="number">0</span>, <span class="string">&quot;Product&quot;</span>));</span><br><span class="line">    <span class="title class_">ClassDef</span> <span class="title function_">book</span>(makeClass&lt;<span class="title class_">Book</span>&gt;(base, <span class="string">&quot;Book&quot;</span>));</span><br><span class="line">    book.<span class="title function_">newObject</span>();</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="C-对象"><a href="#C-对象" class="headerlink" title="C++对象"></a>C++对象</h3><p>我们想要的是真实C++对象，我们也可以通过MOP访问，即通过接口。OO的方法是从中派生我们的，但是尽管其他像Smalltalk这样的OO语言这样做，但我认为有一个更好，侵入性更小的选择：我们提供了一个适配器。<br>从 [<a href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk4">4</a>] 中，我们了解到适配器模式有两个选项：将适配器类设计为仅派生自并包含成员的转发包装类，或者使用多重继承并从 和 派生适配器。为简单起见，我们将使用第一个选项，但实际应用程序通常受益于第二种方法。因此，我们提供了一个包装类，该类派生自并保存原始C++对象。它通过我们的 s 实现 （ 和 ） 的接口：<br>OO 设计的一个有用规则说，只有叶类应该是具体的，所以让我们定义为抽象基类，并创建一个类似于我们前者的真实 MOP 类实例的新类（图 7）。<br><img src="/build-vnc/fig7.jpg" alt="Fig. 7: Object Hierarchy"><br>图 7：对象层次结构<br>如果我们现在执行 一个 ，我们仍然会出错：我们现在得到一个 ，但我们想要一个 。为了解决这个问题，我们必须为 提供一种创建正确类型对象的方法，最简单的方法是工厂方法：我们在 and 中提供一个静态创建函数，为 和 提供指向该函数的指针，将其存储在 并使用该函数：<br>创建函数和 ：<br>对 的更改 ：和对 的简单更改 ：<br>现在，一切正常。嗯，差不多。如果我们现在尝试用编译器创建一个 for，则会抱怨创建一个抽象类：给构造函数一个指向 的指针，这会创建一个实例作为 的一部分。这很容易修复：只需使用创建函数的空指针直接调用构造函数，从而禁止通过 MOP 创建 Product 实例。<code>Object``Product``Object``Object``Product``Object``Product``CppObject``Object``Object``getValue()``setValue()``MemPtr</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">    template &lt;typename <span class="title class_">OrigClass</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CppObject</span> : <span class="keyword">public</span> <span class="title class_">Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        typedef <span class="title class_">MemPtr</span>&lt;<span class="title class_">OrigClass</span>, <span class="title class_">BaseValue</span>&gt; <span class="title class_">MemberPtr</span>;</span><br><span class="line">    <span class="attr">public</span>:</span><br><span class="line">        <span class="title class_">CppObject</span>(<span class="title class_">ClassDef</span> <span class="keyword">const</span> * myClass)</span><br><span class="line">         : <span class="title class_">Object</span>(myClass), <span class="title function_">myObject</span>(), <span class="title function_">members</span>(<span class="params">OrigClass::memberBegin()</span>)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual <span class="title class_">Object</span> * <span class="title function_">clone</span>() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CppObject</span>(*<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        using <span class="title class_">Object</span>::getValue; <span class="comment">// importing getValue(name)</span></span><br><span class="line">        using <span class="title class_">Object</span>::setValue; <span class="comment">// importing setValue(name)</span></span><br><span class="line"></span><br><span class="line">        virtual <span class="title class_">Value</span> <span class="title function_">getValue</span>(size_t idx) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> members[idx].<span class="title function_">value</span>(myObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual <span class="built_in">void</span> <span class="title function_">setValue</span>(<span class="params">size_t idx, Value <span class="keyword">const</span> &amp; v</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">BaseValue</span> * p = &amp;(members[idx].<span class="title function_">value</span>(myObject));</span><br><span class="line">            p-&gt;<span class="title function_">set</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">private</span>:</span><br><span class="line">        <span class="title class_">MemberPtr</span> * members;</span><br><span class="line">        <span class="title class_">OrigClass</span> myObject;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="title class_">Object</span><span class="string">``</span><span class="title class_">DynaObject</span><span class="string">``</span><span class="title class_">Object</span><span class="string">``</span>prod.<span class="title function_">newObject</span>()<span class="string">``</span><span class="title class_">DynaObject</span><span class="string">``</span><span class="title class_">CppObject</span><span class="string">``</span><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">CppObject</span>&lt;&gt;<span class="string">``</span><span class="title class_">DynaObject</span><span class="string">``</span><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">ClassDef</span>::<span class="title function_">newObject</span>()<span class="string">``</span><span class="title class_">DynaObject</span><span class="string">``</span><span class="title class_">CppObject</span></span><br><span class="line">    <span class="title class_">Object</span> *</span><br><span class="line">    <span class="title class_">DynaObject</span>::<span class="title function_">newObject</span>(<span class="params">ClassDef <span class="keyword">const</span> * myClass</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DynaObject</span>(myClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;typename <span class="title class_">OrigClass</span>&gt;</span><br><span class="line">    <span class="title class_">Object</span> *</span><br><span class="line">    <span class="title class_">CppObject</span>&lt;<span class="title class_">OrigClass</span>&gt;::<span class="title function_">newObject</span>(<span class="params">ClassDef <span class="keyword">const</span> * myClass</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CppObject</span>(myClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="title class_">ClassDef</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ClassDef</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">public</span>:</span><br><span class="line">        typedef <span class="title class_">Object</span> * (*<span class="title class_">CreateObjFunc</span>)(<span class="title class_">ClassDef</span> <span class="keyword">const</span> *);</span><br><span class="line"></span><br><span class="line">        template &lt;typename <span class="title class_">Iterator</span>&gt;</span><br><span class="line">        <span class="title class_">ClassDef</span>(<span class="title class_">ClassDef</span> <span class="keyword">const</span> *, <span class="built_in">string</span> <span class="keyword">const</span> &amp;,</span><br><span class="line">                 <span class="title class_">CreateObjFunc</span> objFunc,</span><br><span class="line">                 <span class="title class_">Iterator</span>, <span class="title class_">Iterator</span>)</span><br><span class="line">         : <span class="comment">// ...</span></span><br><span class="line">           <span class="title function_">createObj</span>(<span class="params">objFunc</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">ClassDef</span>(<span class="title class_">ClassDef</span> <span class="keyword">const</span> *, <span class="built_in">string</span> &amp; <span class="keyword">const</span> name_,</span><br><span class="line">                 <span class="title class_">CreateObjFunc</span> objFunc)</span><br><span class="line">         : <span class="comment">// ...</span></span><br><span class="line">           <span class="title function_">createObj</span>(<span class="params">objFunc</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Object</span> * <span class="title function_">newObject</span>() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            definitionFix = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> (*createObj)(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... as before</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">CreateObjFunc</span> createObj;</span><br><span class="line">        <span class="comment">// ... as before</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">makeClass</span><br><span class="line">    template &lt;typename <span class="title class_">CppClass</span>&gt;</span><br><span class="line">    <span class="title class_">ClassDef</span> <span class="title function_">makeClass</span>(<span class="params">ClassDef <span class="keyword">const</span> * base, <span class="built_in">string</span> <span class="keyword">const</span> &amp; name</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ClassDef</span>(base, name,</span><br><span class="line">                        <span class="title class_">CppObject</span>&lt;<span class="title class_">CppClass</span>&gt;::newObject,</span><br><span class="line">                        <span class="title class_">CppClass</span>::<span class="title function_">ownAttribBegin</span>(),</span><br><span class="line">                        <span class="title class_">CppClass</span>::<span class="title function_">ownAttribEnd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">Product</span><span class="string">``</span>makeClass<span class="string">``</span>makeClass<span class="string">``</span><span class="title class_">ClassDef</span><span class="string">``</span><span class="title class_">CppObject</span>::<span class="title function_">newObject</span>()<span class="string">``</span><span class="title class_">Product</span><span class="string">``</span><span class="title class_">CppObject</span><span class="string">``</span><span class="title class_">ClassDef</span></span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MOP，就像你现在拥有的那样，允许你像以前一样将C++类定义为MOP类：<br>你可以创建它们的</p>
<p>实例 你可以定义派生自<br>现有类和新类的新类，并通过MOP操作现有类和新类的实例：<br>C++对象：<br>和动态对象：</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">    ClassDef base(<span class="number">0</span>, <span class="string">&quot;Product&quot;</span>, <span class="number">0</span>,</span><br><span class="line">                  Product::ownAttribBegin(),</span><br><span class="line">                  Product::ownAttribEnd());</span><br><span class="line">    ClassDef book(makeClass&lt;Book&gt;(&amp;base, <span class="string">&quot;Book&quot;</span>));</span><br><span class="line">    </span><br><span class="line">book.newObject();``Product</span><br><span class="line">    ClassDef * tShirt</span><br><span class="line">        = <span class="keyword">new</span> ClassDef(&amp;base, <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">              DynaObject::newObject);</span><br><span class="line"></span><br><span class="line">    tShirt-&gt;addAttribute(Attribute(<span class="string">&quot;Size&quot;</span>, Type::stringT));</span><br><span class="line">    tShirt-&gt;addAttribute(Attribute(<span class="string">&quot;Color&quot;</span>, Type::stringT));</span><br><span class="line">    tShirt-&gt;addAttribute(Attribute(<span class="string">&quot;Name&quot;</span>, Type::stringT));</span><br><span class="line">    tShirt-&gt;addAttribute(Attribute(<span class="string">&quot;Price&quot;</span>, Type::doubleT));</span><br><span class="line"></span><br><span class="line">    classReg.registerClass(tShirt);</span><br><span class="line">    </span><br><span class="line">    Object * ecpp(book.newObject());</span><br><span class="line"></span><br><span class="line">    ecpp-&gt;setValue(<span class="number">5</span>, RealValue&lt;<span class="keyword">double</span>&gt;(<span class="number">22.50</span>));</span><br><span class="line">    ecpp-&gt;setValue(<span class="number">0</span>, RealValue&lt;<span class="keyword">int</span>&gt;(<span class="number">23456</span>));</span><br><span class="line">    ecpp-&gt;setValue(<span class="number">2</span>, RealValue&lt;<span class="keyword">string</span>&gt;(<span class="string">&quot;Scott Meyers&quot;</span>));</span><br><span class="line">    ecpp-&gt;setValue(<span class="string">&quot;Title&quot;</span>, RealValue&lt;<span class="keyword">string</span>&gt;(<span class="string">&quot;Effective C++&quot;</span>));</span><br><span class="line">    ecpp-&gt;setValue(<span class="number">6</span>, RealValue&lt;<span class="keyword">double</span>&gt;(<span class="number">280</span>));</span><br><span class="line">    size_t idx;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ecpp:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (a = book.attribBegin(), idx = <span class="number">0</span>;</span><br><span class="line">         a != book.attribEnd();</span><br><span class="line">         ++a, ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a-&gt;getName() &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">             &lt;&lt; ecpp-&gt;getValue(idx).asString() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ecpp-&gt;getValue(<span class="string">&quot;Author&quot;</span>).asString() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Object * ts(tShirt.newObject());</span><br><span class="line">    ts-&gt;setValue(<span class="number">0</span>, RealValue&lt;<span class="keyword">int</span>&gt;(<span class="number">87654</span>));</span><br><span class="line">    ts-&gt;setValue(<span class="number">2</span>, RealValue&lt;<span class="keyword">string</span>&gt;(<span class="string">&quot;XXL&quot;</span>));</span><br><span class="line">    ts-&gt;setValue(<span class="string">&quot;Color&quot;</span>, RealValue&lt;<span class="keyword">string</span>&gt;(<span class="string">&quot;red&quot;</span>));</span><br><span class="line">    ts-&gt;setValue(<span class="string">&quot;Price&quot;</span>, RealValue&lt;<span class="keyword">double</span>&gt;(<span class="number">25.95</span>));</span><br><span class="line">    ts-&gt;setValue(<span class="string">&quot;Weight&quot;</span>, RealValue&lt;<span class="keyword">double</span>&gt;(<span class="number">387</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t idx = <span class="number">0</span>; idx != <span class="number">4</span>; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ts-&gt;getValue(idx).asString() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="C-接口"><a href="#C-接口" class="headerlink" title="C++接口"></a>C++接口</h3><p>您无法通过接口访问 MOP 创建的实例。对于C++类的实例，您可以修改 要派生自，如前所述，或者更好的是，提供一个成员函数，该函数返回指向 的指针。对于MOP类的实例，您可以在实现接口的周围定义一个包装器：<br>并且您无法通过MOP访问正常的C++实例;为了解决这个问题，你可以添加另一个通过复制来采用C++实例的构造函数（因此你应该删除原始构造函数以避免存在两次的对象），或者你可以修改包装器以仅保存指向C++对象的指针，并添加一个成员函数以根据请求返回受控C++对象： 在这里，我们使用第一种方法：<br>现在，您可以执行此操作：<br>但通常，重要的是您可以在编程时C++定义基本类，但允许用户在运行时从这些基类派生自己的类。<code>Product``CppObject``T``CppObject``myObject``Object``Product</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">DynaProduct</span> : <span class="keyword">public</span> Product</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DynaProduct</span>(Object <span class="type">const</span> * o) : <span class="built_in">obj</span>(o) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;std::string&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Price&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getWeight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Weight&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Object <span class="type">const</span> * <span class="type">const</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">Book</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OrigClass&gt;</span><br><span class="line">        CppObject&lt;OrigClass&gt;::<span class="built_in">CppObject</span>(ClassDef <span class="type">const</span> * myClass,</span><br><span class="line">                                        OrigClass <span class="type">const</span> &amp; obj)</span><br><span class="line">         : <span class="built_in">Object</span>(myClass),</span><br><span class="line">           <span class="built_in">myObject</span>(obj), <span class="comment">// calls the copy-ctor of OrigClass,</span></span><br><span class="line">                             <span class="function">which must be accessible</span></span><br><span class="line"><span class="function">           <span class="title">members</span><span class="params">(OrigClass::memberBegin())</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Book <span class="title">b</span><span class="params">(<span class="string">&quot;Bjarne Stroustrup&quot;</span>, <span class="string">&quot;The C++ Programming Language&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;Addison-Wesley&quot;</span>, <span class="number">27.50</span>, <span class="number">370</span>)</span></span>;</span><br><span class="line">    <span class="function">CppObject&lt;Book&gt; <span class="title">mb</span><span class="params">(*book, b)</span></span>;</span><br><span class="line">    Object * ob = &amp;mb;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++ object through MOP&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (a = ob-&gt;<span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribBegin</span>(), idx = <span class="number">0</span>;</span><br><span class="line">         a != ob-&gt;<span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribEnd</span>();</span><br><span class="line">         ++a, ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">             &lt;&lt; ob-&gt;<span class="built_in">getValue</span>(idx).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>使用QT编写的代码编辑器</title>
    <url>/2022/03/18/codeedit/</url>
    <content><![CDATA[<p>使用QT编写的代码编辑器,采用MVC模式架构，数据与代码分离</p>
<span id="more"></span>

<h3 id="使用QT编写的代码编辑器"><a href="#使用QT编写的代码编辑器" class="headerlink" title="使用QT编写的代码编辑器"></a>使用QT编写的代码编辑器</h3><p>界面展示</p>
<p><img src="/2022/03/18/codeedit/main.png"></p>
<p>核心编辑框使用外部库QScilllina</p>
<p>采用MVC模式架构，数据与代码分离</p>
<p>TreeMenu实现不同Item映射不同菜单</p>
<p><img src="/2022/03/18/codeedit/code.png"></p>
]]></content>
  </entry>
  <entry>
    <title>pinn相关研究与研究进展</title>
    <url>/2022/03/18/pinn/</url>
    <content><![CDATA[<p>pinn相关研究与研究进展,相关论文总结与文献综述</p>
<span id="more"></span>

<h1 id="pinn求解非线性PDE"><a href="#pinn求解非线性PDE" class="headerlink" title="pinn求解非线性PDE"></a>pinn求解非线性PDE</h1><h2 id="引入相关库文件"><a href="#引入相关库文件" class="headerlink" title="引入相关库文件"></a>引入相关库文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.set_default_tensor_type(torch.DoubleTensor)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构造网络"><a href="#构造网络" class="headerlink" title="构造网络"></a>构造网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承torch的nn模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化构造函数</span></span><br><span class="line">    <span class="comment"># hidden_num:   隐藏层数量</span></span><br><span class="line">    <span class="comment"># vertices_num: 每层神经元个数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hidden_num, vertices_num</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入层</span></span><br><span class="line">        self.input_layer = nn.Linear(<span class="number">2</span>, vertices_num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 隐藏层</span></span><br><span class="line">        self.hidden_layers = nn.ModuleList([nn.Linear(vertices_num, vertices_num) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hidden_num)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出层</span></span><br><span class="line">        self.output_layer = nn.Linear(vertices_num, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        o = self.act(self.input_layer(x))</span><br><span class="line">        <span class="keyword">for</span> i, li <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.hidden_layers):</span><br><span class="line">            o = self.act(li(o))</span><br><span class="line">        out = self.output_layer(o)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 激活函数:反正切</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * torch.sigmoid(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置加速器:Adam</span></span><br><span class="line">    <span class="comment"># lr: 误差控制</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_optimizer</span>(<span class="params">self, lr</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.optim.Adam(self.parameters(), lr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="损失函数构造"><a href="#损失函数构造" class="headerlink" title="损失函数构造"></a>损失函数构造</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 求偏导函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradients</span>(<span class="params">u, x, order=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> order == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> torch.autograd.grad(u, x, grad_outputs=torch.ones_like(u),</span><br><span class="line">                                   create_graph=<span class="literal">True</span>,</span><br><span class="line">                                   only_inputs=<span class="literal">True</span>, )[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gradients(gradients(u, x), x, order=order - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interior</span>(<span class="params">size=<span class="number">2000</span></span>):</span><br><span class="line">    x = -<span class="number">1</span> + <span class="number">2</span> * torch.rand(size, <span class="number">1</span>)</span><br><span class="line">    t = torch.rand(size, <span class="number">1</span>)</span><br><span class="line">    cond = torch.zeros(size, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x.requires_grad_(<span class="literal">True</span>), t.requires_grad_(<span class="literal">True</span>), cond.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boundary2</span>(<span class="params">size=<span class="number">2000</span></span>):</span><br><span class="line">    x = <span class="number">1</span> - <span class="number">2</span> * torch.ones(size, <span class="number">1</span>)</span><br><span class="line">    t = torch.rand(size, <span class="number">1</span>)</span><br><span class="line">    cond = torch.zeros(size, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x.requires_grad_(<span class="literal">True</span>), t.requires_grad_(<span class="literal">True</span>), cond.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boundary1</span>(<span class="params">size=<span class="number">2000</span></span>):</span><br><span class="line">    x = torch.ones(size, <span class="number">1</span>)</span><br><span class="line">    t = torch.rand(size, <span class="number">1</span>)</span><br><span class="line">    cond = torch.zeros(size, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x.requires_grad_(<span class="literal">True</span>), t.requires_grad_(<span class="literal">True</span>), cond.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initial_value</span>(<span class="params">size=<span class="number">2000</span></span>):</span><br><span class="line">    x = torch.rand(size, <span class="number">1</span>)</span><br><span class="line">    t = torch.zeros(size, <span class="number">1</span>)</span><br><span class="line">    cond = -torch.sin(np.pi * x)</span><br><span class="line">    <span class="keyword">return</span> x.requires_grad_(<span class="literal">True</span>), t.requires_grad_(<span class="literal">True</span>), cond.requires_grad_(<span class="literal">True</span>).requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_interior</span>(<span class="params">net</span>):</span><br><span class="line">    x, t, cond = interior()</span><br><span class="line">    uxy = net(torch.cat([x, t], dim=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> loss(gradients(uxy, t, <span class="number">1</span>) + gradients(uxy, x, <span class="number">1</span>) * uxy - (<span class="number">0.01</span> / np.pi) * gradients(uxy, x, <span class="number">2</span>), cond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_boundary2</span>(<span class="params">net</span>):</span><br><span class="line">    x, t, cond = boundary2()</span><br><span class="line">    uxy = net(torch.cat([x, t], dim=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> loss(uxy, cond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_boundary1</span>(<span class="params">net</span>):</span><br><span class="line">    x, t, cond = boundary1()</span><br><span class="line">    uxy = net(torch.cat([x, t], dim=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> loss(uxy, cond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_initial_value</span>(<span class="params">net</span>):</span><br><span class="line">    x, t, cond = initial_value()</span><br><span class="line">    uxy = net(torch.cat([x, t], dim=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> loss(uxy, cond)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Net(<span class="number">10</span>, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">loss_data = []</span><br><span class="line"></span><br><span class="line">opt = torch.optim.Adam(params=net.parameters(), lr=<span class="number">1e-7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    opt.zero_grad()</span><br><span class="line">    l = loss_interior(net) + loss_boundary1(net) + loss_initial_value(net) + loss_boundary2(net)</span><br><span class="line">    l.backward()</span><br><span class="line">    opt.step()</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="built_in">print</span>(l.item())</span><br><span class="line">    loss_data.append([i, l.item()])</span><br><span class="line"></span><br><span class="line">torch.save(net, <span class="string">&#x27;./data/net.pkl&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$$<br>\displaystyle<br>        \left{\begin{array}{c}</p>
<pre><code>        \frac&#123;\partial C&#125;&#123;\partial t&#125;=D \frac&#123;\partial^&#123;2&#125; C&#125;&#123;\partial x^&#123;2&#125;&#125; ;(0&lt;x&lt;1, t&gt;0) 
        \\
        \frac&#123;\partial C&#125;&#123;\partial x&#125;(0, t)=\pi e^&#123;-\pi^&#123;2&#125; t&#125; \cos (\pi x) 
        \\ 
        C(l, t)=0 ;(0 \leq x \leq 1) 
        \\
        C(x, 0)=\sin (\pi x) ;(t \geq 0)
    \end&#123;array&#125;\right.
</code></pre>
<p>$$</p>
]]></content>
      <tags>
        <tag>pinn</tag>
      </tags>
  </entry>
  <entry>
    <title>mainpage</title>
    <url>/2022/03/18/mainpage/</url>
    <content><![CDATA[<p>记录一些常见的latex公式，方便书写</p>
<span id="more"></span>

<h3 id="1-数学公式"><a href="#1-数学公式" class="headerlink" title="1.数学公式"></a>1.数学公式</h3><table>
<thead>
<tr>
<th>符号</th>
<th>公式</th>
<th></th>
<th>符号</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>\int</td>
<td>$\int$</td>
<td></td>
<td>a_1</td>
<td>$a_1$</td>
</tr>
<tr>
<td>\iint</td>
<td>$\iint$</td>
<td></td>
<td>a^2</td>
<td>$a^2$</td>
</tr>
<tr>
<td>\iiint</td>
<td>$\iiint$</td>
<td></td>
<td>\bar{x}</td>
<td>$\bar{x}$</td>
</tr>
<tr>
<td>\lim</td>
<td>$\lim_{n =1}$</td>
<td></td>
<td>\vec{x}</td>
<td>$\vec{x}$</td>
</tr>
<tr>
<td>\lim\limits_{n = 1}</td>
<td>$\lim\limits_{n=1}$</td>
<td></td>
<td>\dots</td>
<td>$x_1,x_2,\dots,x_n$</td>
</tr>
<tr>
<td>\sum</td>
<td>$\sum$</td>
<td></td>
<td>\cdots</td>
<td>$x_1,x_2,\cdots,x_n$</td>
</tr>
<tr>
<td>\prod</td>
<td>$\prod$</td>
<td></td>
<td>\ddots</td>
<td>$x_1,x_2,\ddots,x_n$</td>
</tr>
<tr>
<td>\sum\limits_{n = 1}^{\infty}</td>
<td>$\sum\limits_{n = 1}^{\infty}$</td>
<td></td>
<td>\vdots</td>
<td>$x_1,x_2,\vdots,x_n$</td>
</tr>
<tr>
<td>\dfrac{f(x)}{g(x)}</td>
<td>$\dfrac{f(x)}{g(x)}$</td>
<td></td>
<td>矩阵</td>
<td>$\begin{array}{12}x_1&amp;x_2&amp;\dots\x_3&amp;x_4&amp;\dots\\vdots&amp;\vdots&amp;\ddots\end{array}$</td>
</tr>
<tr>
<td>\tfrac{f(x)}{g(x)}(默认)</td>
<td>$\tfrac{f(x)}{g(x)}$</td>
<td></td>
<td>矩阵</td>
<td>$\begin{pmatrix} a &amp; b\ c &amp; d \ \end{pmatrix} \quad  \quad \begin{Bmatrix} a &amp; b \ c &amp; d\ \end{Bmatrix}\quad \begin{vmatrix} a &amp; b \ c &amp; d \ \end{vmatrix}\quad \begin{Vmatrix} a &amp; b\ c &amp; d \ \end{Vmatrix}$</td>
</tr>
<tr>
<td>\boxed{a}</td>
<td>$\boxed{a}$</td>
<td></td>
<td>\quad</td>
<td>$a\quad b$</td>
</tr>
<tr>
<td>\sqrt[n]{x}</td>
<td>$\sqrt[n]{x}$</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>split对齐</th>
<th align="right">$\begin{split}f(x)=&amp;ax^2+bx+c\&amp;dy^2+fy+e\end{split}$</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td align="right">$\begin{cases}f(x)=ax^2+bx+c\g(x)=dy^2+fy+e\end{cases}$</td>
</tr>
<tr>
<td>align对齐</td>
<td align="right">$\begin{align}f(x)=&amp;ax^2+bx+c\g(x)=&amp;dy^2+fy+e\end{align}$</td>
</tr>
<tr>
<td>array</td>
<td align="right">$\begin{array}{12}x_1&amp;x_2&amp;\dots\x_3&amp;x_4&amp;\dots\\vdots&amp;\vdots&amp;\ddots\end{array}$</td>
</tr>
</tbody></table>
<p><img src="/2022/03/18/mainpage/QQ%E6%88%AA%E5%9B%BE20200304195537.png"></p>
]]></content>
      <tags>
        <tag>main</tag>
      </tags>
  </entry>
</search>
