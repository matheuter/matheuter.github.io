<!DOCTYPE html>
<html lang="zh-CH">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#fffff1"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#fffff1">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.likepanda.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":10,"offset":5},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="编译原理">
<meta property="og:type" content="article">
<meta property="og:title" content="compiler">
<meta property="og:url" content="http://www.likepanda.cn/2023/03/14/compiler/index.html">
<meta property="og:site_name" content="rivia site">
<meta property="og:description" content="编译原理">
<meta property="og:locale" content="zh_CH">
<meta property="article:published_time" content="2023-03-14T03:57:41.000Z">
<meta property="article:modified_time" content="2023-03-14T04:22:40.563Z">
<meta property="article:author" content="Jok Brown">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.likepanda.cn/2023/03/14/compiler/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CH","comments":true,"permalink":"http://www.likepanda.cn/2023/03/14/compiler/","path":"2023/03/14/compiler/","title":"compiler"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>compiler | rivia site</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">rivia site</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">deep thinking</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于rivia</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>博客归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索本站
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第一章 编译概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q1-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%B0%86%E4%BB%96%E4%BB%AC%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5"><span class="nav-number">1.1.</span> <span class="nav-text">Q1. 高级语言，汇编语言和机器语言的关系？编译器如何将他们联系起来?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q2-%E7%AE%80%E8%BF%B0%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E6%AF%8F%E4%B8%AA%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-number">1.2.</span> <span class="nav-text">Q2.简述编译程序结构，并说明每个部分的作用。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%B8%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">第二章 词法分析器与有限自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A8%E5%AF%BC%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%84%E7%BA%A6%EF%BC%9F%E5%B9%B6%E7%AE%80%E8%BF%B0%E8%A7%84%E8%8C%83%E6%8E%A8%E5%AF%BC%E5%92%8C%E8%A7%84%E8%8C%83%E5%BD%92%E7%BA%A6%E3%80%82"><span class="nav-number">2.1.</span> <span class="nav-text">Q3.什么是推导，什么是规约？并简述规范推导和规范归约。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%8C%E5%85%B6%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">Q4.什么是语法树，其优点是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%B3%95%E4%BA%8C%E4%B9%89%E6%80%A7%EF%BC%9F%E6%80%8E%E6%A0%B7%E6%B6%88%E9%99%A4%E6%96%87%E6%B3%95%E4%BA%8C%E4%B9%89%E6%80%A7%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">Q5.什么是文法二义性？怎样消除文法二义性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q6-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%8F%A5%E5%AD%90w%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">Q6.怎样判断某个句子w是否合法？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%B8%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">3.</span> <span class="nav-text">第三章 词法分析器与有限自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q7-%E4%BB%80%E4%B9%88%E6%98%AFDFA%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFNFA%EF%BC%9F%E7%AE%80%E8%BF%B0%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E3%80%82"><span class="nav-number">3.1.</span> <span class="nav-text">Q7.什么是DFA，什么是NFA？简述他们的区别和联系。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q8-%E7%AE%80%E8%BF%B0NFA%E7%A1%AE%E5%AE%9A%E5%8C%96%E4%B8%BADFA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">3.2.</span> <span class="nav-text">Q8.简述NFA确定化为DFA的基本思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q9-%E7%AE%80%E8%BF%B0DFA%E6%9C%80%E7%AE%80%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">3.3.</span> <span class="nav-text">Q9.简述DFA最简化的基本思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q10-%E8%AF%B4%E6%98%8E%E6%AD%A3%E8%A7%84%E5%BC%8F%EF%BC%8C%E6%AD%A3%E8%A7%84%E9%9B%86%E5%92%8C%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%AD%A3%E8%A7%84%E5%BC%8F%E7%AD%89%E4%BB%B7%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">Q10.说明正规式，正规集和正规文法的关系。以及如何判断两个正规式等价？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">第四章 自顶向下的语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q11-%E7%AE%80%E8%BF%B0%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%9D%A2%E4%B8%B4%E4%B8%BB%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-number">4.1.</span> <span class="nav-text">Q11.简述自顶向下的语法分析的基本思想，以及面临主要的问题。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q12-FIRST%E9%9B%86%E5%92%8CFOLLOW%E9%9B%86%E5%88%86%E5%88%AB%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">Q12.FIRST集和FOLLOW集分别表示什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q13-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9C%89%E6%97%A0%E5%9B%9E%E6%BA%AF%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">Q13.如何判断有无回溯？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q14-%E7%AE%80%E8%BF%B0LL-1-%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="nav-number">4.4.</span> <span class="nav-text">Q14.简述LL(1)分析法的工作原理。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">第五章 自底向上的语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q15-%E7%AE%80%E8%BF%B0%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%9D%A2%E4%B8%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-number">5.1.</span> <span class="nav-text">Q15.简述自底向上的语法分析的基本思想，以及面临的主要问题。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q16-%E4%BB%8B%E7%BB%8D%E7%A7%BB%E8%BF%9B-%E5%BD%92%E7%BA%A6%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">5.2.</span> <span class="nav-text">Q16.介绍移进-归约法的基本思想。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q17-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A0%E7%9F%AD%E8%AF%AD%E5%92%8C%E6%9C%80%E5%B7%A6%E7%B4%A0%E7%9F%AD%E8%AF%AD%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">Q17.什么是素短语和最左素短语？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q18-%E7%AE%80%E8%BF%B0%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="nav-number">5.4.</span> <span class="nav-text">Q18.简述算符优先分析法的工作原理。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q19-%E6%B4%BB%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">Q19.活前缀的作用是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q20-%E6%B1%82%E4%BC%98%E5%85%88%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">Q20.求优先函数的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q21-%E4%BB%80%E4%B9%88%E6%98%AFLR-0-%E9%A1%B9%E7%9B%AE%E9%9B%86%E8%A7%84%E8%8C%83%E7%B0%87%EF%BC%9F%E4%BB%A5%E5%8F%8ALR-0-%E9%A1%B9%E7%9B%AE%E9%9B%86%E4%B8%AD%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E5%86%B2%E7%AA%81%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="nav-number">5.7.</span> <span class="nav-text">Q21.什么是LR(0)项目集规范簇？以及LR(0)项目集中有哪两种冲突形式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q22-%E7%9B%B8%E8%BE%83%E4%BA%8ELR-0-%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%8CSLR-1-%E5%88%86%E6%9E%90%E6%B3%95%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%9F"><span class="nav-number">5.8.</span> <span class="nav-text">Q22.相较于LR(0)分析法，SLR(1)分析法如何提高分析能力？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q23-LR-1-%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%E7%9A%84%EF%BC%9F"><span class="nav-number">5.9.</span> <span class="nav-text">Q23.LR(1)分析技术是如何提高分析能力的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">第六章 属性文法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q24-%E4%BB%8B%E7%BB%8D%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%AF%AD%E4%B9%89%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82"><span class="nav-number">6.1.</span> <span class="nav-text">Q24.介绍属性，语义规则以及属性文法的概念。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q25-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">Q25.什么是综合属性，什么是继承属性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q26-%E4%BB%80%E4%B9%88%E6%98%AFS-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFL-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">Q26.什么是S-属性文法，什么是L-属性文法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q27-%E7%AE%80%E8%BF%B0%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E7%BF%BB%E8%AF%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">6.4.</span> <span class="nav-text">Q27.简述语法制导的语义翻译的基本思想。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q28-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">Q28.什么是翻译方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q29-%E6%80%8E%E6%A0%B7%E6%8C%87%E5%AF%BC%E5%B0%86%E8%AF%AD%E4%B9%89%E5%8A%A8%E4%BD%9C%E6%8F%92%E5%85%A5%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8A%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">Q29.怎样指导将语义动作插入到合适的位置上？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="nav-number">7.</span> <span class="nav-text">第七章 语义分析与语法制导的翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q30-%E7%94%9F%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">Q30.生成中间代码有什么好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q31-%E7%AE%80%E8%BF%B0%E2%80%9C%E5%9B%9E%E5%A1%AB%E2%80%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">7.2.</span> <span class="nav-text">Q31.简述“回填”技术的思想。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="nav-number">8.</span> <span class="nav-text">第八章 运行时空间分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q32-%E8%AF%B4%E6%98%8EC%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E3%80%82"><span class="nav-number">8.1.</span> <span class="nav-text">Q32.说明C语言运行时的空间分配策略。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q33-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BB%E5%8A%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%EF%BC%9FC%E8%AF%AD%E8%A8%80%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">Q33.什么是活动，什么是活动记录？C语言活动记录的结构是怎样的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">第九章 代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q34-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%8C%96%EF%BC%9F%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">9.1.</span> <span class="nav-text">Q34.什么是优化？优化原则有什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q35-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%9C%AC%E5%9D%97%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%88%92%E5%88%86%E5%9F%BA%E6%9C%AC%E5%9D%97%EF%BC%9F"><span class="nav-number">9.2.</span> <span class="nav-text">Q35.什么是基本块？怎样划分基本块？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q36-%E7%AE%80%E8%BF%B0%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96%E5%92%8C%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-number">9.3.</span> <span class="nav-text">Q36.简述局部优化和循环优化的过程。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q37-%E7%AE%80%E8%BF%B0%E5%88%A9%E7%94%A8DAG%E5%9B%BE%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E5%9D%97%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%82"><span class="nav-number">9.4.</span> <span class="nav-text">Q37. 简述利用DAG图进行基本块优化的基本思想。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">10.</span> <span class="nav-text">第十章 目标代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q38-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%BB%E8%A6%81%E5%BA%94%E8%80%83%E8%99%91%E5%93%AA%E5%87%A0%E6%96%B9%E9%9D%A2%E7%9A%84%E5%9B%A0%E7%B4%A0%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">Q38.目标代码生成主要应考虑哪几方面的因素？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">11.</span> <span class="nav-text">引言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">1.什么是数据库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">11.2.</span> <span class="nav-text">2.什么是关系数据模型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">11.3.</span> <span class="nav-text">3.数据抽象的三个层次是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%9F"><span class="nav-number">11.4.</span> <span class="nav-text">4.什么是数据独立性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">11.5.</span> <span class="nav-text">5.什么是数据库的三级模式结构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8F%AF%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="nav-number">11.6.</span> <span class="nav-text">6.数据库设计可分为哪几个阶段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9D%A5%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E6%98%AF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="nav-number">11.7.</span> <span class="nav-text">7.为什么不用文件处理系统来存储组织信息，而是用数据库系统？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-SQL%E8%AF%AD%E5%8F%A5%E6%8C%89%E7%85%A7%E5%8A%9F%E8%83%BD%E5%8F%AF%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-number">11.8.</span> <span class="nav-text">8.SQL语句按照功能可分为哪几个部分？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.</span> <span class="nav-text">1.2 数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%91%E5%B1%95%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%AD%EF%BC%8C%E6%80%BB%E5%85%B1%E5%87%BA%E7%8E%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">1.在数据库发展的历史中，总共出现过哪些数据模型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">12.2.</span> <span class="nav-text">2.关系数据模型中的关系指的是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%98%AF%E7%9B%AE%E5%89%8D%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B9%BF%E6%B3%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">12.3.</span> <span class="nav-text">3.为什么关系数据模型是目前使用最广泛的数据模型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">12.4.</span> <span class="nav-text">4.什么是主键？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E9%94%AE%EF%BC%9F"><span class="nav-number">12.5.</span> <span class="nav-text">5.什么是外键？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">12.6.</span> <span class="nav-text">6.关系代数的基本操作有哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="nav-number">13.</span> <span class="nav-text">1.3 数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF1NF%E3%80%812NF%E3%80%813NF%E3%80%814NF%E3%80%815NF%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">1.什么是1NF、2NF、3NF、4NF、5NF？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">13.2.</span> <span class="nav-text">2.有哪些数据依赖关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%87%87%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-number">13.3.</span> <span class="nav-text">3.数据库设计采用的方法有哪几种？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-4-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">14.</span> <span class="nav-text">1.4 数据存储和查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">1.文件中记录的组织形式有哪几种？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%EF%BC%9F"><span class="nav-number">14.2.</span> <span class="nav-text">2.查询优化可以在哪两个方面进行？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-5-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">15.</span> <span class="nav-text">1.5 事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F%E4%BA%8B%E5%8A%A1%E5%85%B7%E6%9C%89%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E4%B8%AA%E7%89%B9%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">15.1.</span> <span class="nav-text">1.什么是事务？事务具有的特性是什么？每个特性的含义分别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E5%90%97%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E5%AF%B9%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">15.2.</span> <span class="nav-text">2.什么是两阶段封锁协议，两阶段封锁协议可以保证不会发生死锁吗？有哪些应对死锁的方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="nav-number">15.3.</span> <span class="nav-text">3.什么是日志？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%90%E4%BA%A4%E8%A7%84%E5%88%99%E3%80%81%E5%85%88%E8%AE%B0%E5%90%8E%E5%86%99%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-number">15.4.</span> <span class="nav-text">4.什么是提交规则、先记后写规则？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%BD%93%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9C%89%E5%A4%9A%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%97%B6%EF%BC%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">15.5.</span> <span class="nav-text">5.当数据库中有多个事务并发执行时，有可能出现哪些问题？如何解决这些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%9C%A8%E4%BD%95%E6%97%B6%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%EF%BC%9F%E5%9C%A8%E6%A3%80%E6%B5%8B%E5%87%BA%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">15.6.</span> <span class="nav-text">6.有哪些检测死锁发生的方式？在何时检测死锁是否发生？在检测出死锁发生后，如何解除死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">15.7.</span> <span class="nav-text">7.如何使用基于时间戳的协议进行死锁避免？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-1-%E5%BC%95%E8%AE%BA"><span class="nav-number">16.</span> <span class="nav-text">2.1 引论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">16.1.</span> <span class="nav-text">1.从高级语言源程序到目标机器代码的全过程是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%85%B7%E4%BD%93%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.2.</span> <span class="nav-text">2.编译程序的工作包括哪些方面？它们具体的含义是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%BB%93%E7%AC%A6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6"><span class="nav-number">16.3.</span> <span class="nav-text">3.什么是终结符、什么是非终结符?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">17.</span> <span class="nav-text">2.2 词法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F"><span class="nav-number">17.1.</span> <span class="nav-text">1.什么是正则表达式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%81%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%81%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">17.2.</span> <span class="nav-text">2.什么是有穷自动机、确定有穷自动机、不确定有穷自动机?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="nav-number">17.3.</span> <span class="nav-text">3.什么是有穷自动机定义的语言？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%B5%8B%E5%88%B0%E5%93%AA%E4%BA%9B%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%EF%BC%9F%E6%98%AF%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E7%9A%84%EF%BC%9F%E5%AF%B9%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">17.4.</span> <span class="nav-text">4.词法分析阶段可以检测到哪些错误类型？是如何检测的？对错误的处理过程是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">18.</span> <span class="nav-text">2.3 语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%EF%BC%9F"><span class="nav-number">18.1.</span> <span class="nav-text">1.什么是上下文无关文法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%EF%BC%9F"><span class="nav-number">18.2.</span> <span class="nav-text">2.什么是语法分析树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95%EF%BC%9F"><span class="nav-number">18.3.</span> <span class="nav-text">3.什么是二义性文法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9F"><span class="nav-number">18.4.</span> <span class="nav-text">4.什么是自顶向下和自底向上语法分析？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A8%E5%AF%BC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E7%BA%A6%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BC%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%8F%B3%E6%8E%A8%E5%AF%BC%EF%BC%9F%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E5%88%86%E5%88%AB%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%8E%A8%E5%AF%BC%E6%88%96%E5%BD%92%E7%BA%A6%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">18.5.</span> <span class="nav-text">5.什么是推导？什么是归约？什么是最左推导？什么是最右推导？自底向上的分析和自顶向下的分析分别采用什么推导或归约方式？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-4-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="nav-number">19.</span> <span class="nav-text">2.4 语法制导的翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%8C%87%E7%9A%84%E6%98%AF%E7%BC%96%E8%AF%91%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="nav-number">19.1.</span> <span class="nav-text">1.语法制导翻译指的是编译的哪几个阶段？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-5-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">20.</span> <span class="nav-text">2.5 中间代码生成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83"><span class="nav-number">21.</span> <span class="nav-text">2.6 运行时刻环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">21.1.</span> <span class="nav-text">1.数据的存储分配策略是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E5%88%92%E5%88%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">21.2.</span> <span class="nav-text">2.程序运行时内存的划分是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%82%E5%90%88%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E7%9A%84%E8%AF%AD%E8%A8%80%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">21.3.</span> <span class="nav-text">3.适合静态存储分配的语言必须满足的限制条件是什么？常用的静态存储分配方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%EF%BC%9F"><span class="nav-number">21.4.</span> <span class="nav-text">4.什么是栈式存储分配？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-7-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">22.</span> <span class="nav-text">2.7 代码生成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E5%9B%BE%EF%BC%9F"><span class="nav-number">22.1.</span> <span class="nav-text">1.什么是流图？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">22.2.</span> <span class="nav-text">2.什么是窥孔优化？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jok Brown</p>
  <div class="site-description" itemprop="description">python c++ qt</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CH">
    <link itemprop="mainEntityOfPage" href="http://www.likepanda.cn/2023/03/14/compiler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jok Brown">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rivia site">
      <meta itemprop="description" content="python c++ qt">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="compiler | rivia site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          compiler
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-14 11:57:41 / 修改时间：12:22:40" itemprop="dateCreated datePublished" datetime="2023-03-14T11:57:41+08:00">2023-03-14</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>编译原理</p>
<span id="more"></span>



<p>【编译原理】计算机考研复试问答总结</p>
<p>因为复试专业课需要考编译原理，线上复试总结一些编译原理的相关题目~<br>（ps:只是一些面试的一些概念简答题，如果有笔试相关类型的题目要好好写）</p>
<h1 id="第一章-编译概述"><a href="#第一章-编译概述" class="headerlink" title="第一章 编译概述"></a>第一章 编译概述</h1><h2 id="Q1-高级语言，汇编语言和机器语言的关系？编译器如何将他们联系起来"><a href="#Q1-高级语言，汇编语言和机器语言的关系？编译器如何将他们联系起来" class="headerlink" title="Q1. 高级语言，汇编语言和机器语言的关系？编译器如何将他们联系起来?"></a>Q1. 高级语言，汇编语言和机器语言的关系？编译器如何将他们联系起来?</h2><p>翻译程序是指把用某种程序设计语言编写的程序（源程序）翻译成与之等价的另一种语言的程序（目标程序）。包括：编译程序，汇编程序和解释程序。<br>编译程序：能够将高级语言编写的源程序翻译成等价的机器语言/汇编语言的目标程序。<br>汇编程序：将汇编语言程序翻译成等价的机器语言程序（可直接在计算机上执行）。<br>解释程序：翻译一句执行一句，不生成目标文件，直接执行源代码文件。</p>
<h2 id="Q2-简述编译程序结构，并说明每个部分的作用。"><a href="#Q2-简述编译程序结构，并说明每个部分的作用。" class="headerlink" title="Q2.简述编译程序结构，并说明每个部分的作用。"></a>Q2.简述编译程序结构，并说明每个部分的作用。</h2><p>(1)词法分析：根据词法规则，对构成输入源程序的字符扫描分解，识别出一个个单词符号。<br>(2)语法分析：在词法分析的基础上，根据语言语法规则，把单词符号分解成各类语法单位。<br>(3)语义处理和中间代码生成：根据语言的语义规则来生成中间代码。<br>(4)代码优化：对程序和中间代码进行等价变换，从变换后的程序出发，能生成更有效的目标代码。<br>(5)目标代码生成：把中间代码变换成特定机器上的低级语言代码。</p>
<h1 id="第二章-词法分析器与有限自动机"><a href="#第二章-词法分析器与有限自动机" class="headerlink" title="第二章 词法分析器与有限自动机"></a>第二章 词法分析器与有限自动机</h1><h2 id="Q3-什么是推导，什么是规约？并简述规范推导和规范归约。"><a href="#Q3-什么是推导，什么是规约？并简述规范推导和规范归约。" class="headerlink" title="Q3.什么是推导，什么是规约？并简述规范推导和规范归约。"></a>Q3.什么是推导，什么是规约？并简述规范推导和规范归约。</h2><p>推导：把句型中的非终结符用产生式规则的右部来替代的过程。<br>归约：把句子中的某个子串（即句柄）用一个非终结符来替代的过程。<br>规范推导：也称最右推导，指对一个推导序列中的每一步直接推导α=&gt;β，都是对阿尔法中的最左非终结符进行替换；规范推导的逆过程成为最左归约，也即规范归约。</p>
<h2 id="Q4-什么是语法树，其优点是什么？"><a href="#Q4-什么是语法树，其优点是什么？" class="headerlink" title="Q4.什么是语法树，其优点是什么？"></a>Q4.什么是语法树，其优点是什么？</h2><p>语法树是一个句型推导的树形表示。<br>其优点是有助于理解一个句子语法结构的层次。</p>
<h2 id="Q5-什么是文法二义性？怎样消除文法二义性？"><a href="#Q5-什么是文法二义性？怎样消除文法二义性？" class="headerlink" title="Q5.什么是文法二义性？怎样消除文法二义性？"></a>Q5.什么是文法二义性？怎样消除文法二义性？</h2><p>文法的二义性：如果一个文法存在某一个句子对应两颗不同的语法树，则称这个文法是二义的。<br>消除文法二义性的方法包括：<br>（1）不改变文法，附加一些限制条件，生成确定的语法树<br>（2）改变文法，构造一个等价的新文法，把排除二义性规则合并到原文法中</p>
<h2 id="Q6-怎样判断某个句子w是否合法？"><a href="#Q6-怎样判断某个句子w是否合法？" class="headerlink" title="Q6.怎样判断某个句子w是否合法？"></a>Q6.怎样判断某个句子w是否合法？</h2><p>（1）从文法的开始符号出发，逐步推导，看能否产生w。若能，则w是合法的句子；<br>（2）从句子w出发，逐步归约，看是否能够归约到文法的开始符号。若能，则w是合法的句子。</p>
<h1 id="第三章-词法分析器与有限自动机"><a href="#第三章-词法分析器与有限自动机" class="headerlink" title="第三章 词法分析器与有限自动机"></a>第三章 词法分析器与有限自动机</h1><h2 id="Q7-什么是DFA，什么是NFA？简述他们的区别和联系。"><a href="#Q7-什么是DFA，什么是NFA？简述他们的区别和联系。" class="headerlink" title="Q7.什么是DFA，什么是NFA？简述他们的区别和联系。"></a>Q7.什么是DFA，什么是NFA？简述他们的区别和联系。</h2><p>DFA(确定的有限自动机)：M是一个五元组，M = ( S，Σ ，δ，S0，F )<br>S：有穷状态集<br>Σ：输入字母表，即输入符号集合。<br>δ：将S×Σ映射到S的转换函数。<br>S0：开始状态<br>F：终止状态集<br>NFA：非确定有限自动机：M是一个五元组，M = ( S，Σ ，δ，S0，F )<br>（状态子集确定，状态不确定）<br>S：有穷状态集<br>Σ：输入符号集合，即输入字母表。假设ε 不是Σ中的元素<br>δ：将S×Σ映射到S的转换函数。<br>S0：开始状态集<br>F：终止状态集<br>DFA是NFA的特例，NFA是DFA的推广。NFA能识别的语言都能被DFA识别，DFA相应的识别程序更容易实现。</p>
<h2 id="Q8-简述NFA确定化为DFA的基本思路"><a href="#Q8-简述NFA确定化为DFA的基本思路" class="headerlink" title="Q8.简述NFA确定化为DFA的基本思路"></a>Q8.简述NFA确定化为DFA的基本思路</h2><p>核心思想：状态子集法<br>基本思路：DFA的每个状态代表NFA状态集合的某个子集，构造的DFA使用它的状态去记录NFA读入输入符号之后可能到达的所有状态的集合。</p>
<h2 id="Q9-简述DFA最简化的基本思路"><a href="#Q9-简述DFA最简化的基本思路" class="headerlink" title="Q9.简述DFA最简化的基本思路"></a>Q9.简述DFA最简化的基本思路</h2><p>DFA中的有些状态是等价的。如果从状态S出发，经过任意符号串，能够到达终止状态，对于同一个串t，状态W也能终止，则状态S和W等价。两个终止状态可以不同，只要终止就可以。<br>不等价：找出一个串t,S出发可以终止，W出发不能到达终止状态。<br>将这些等价的状态进行合并，就可以简化DFA。</p>
<h2 id="Q10-说明正规式，正规集和正规文法的关系。以及如何判断两个正规式等价？"><a href="#Q10-说明正规式，正规集和正规文法的关系。以及如何判断两个正规式等价？" class="headerlink" title="Q10.说明正规式，正规集和正规文法的关系。以及如何判断两个正规式等价？"></a>Q10.说明正规式，正规集和正规文法的关系。以及如何判断两个正规式等价？</h2><p>正规式：是描述程序语言单词的表达式，是一种表示正规集的工具。<br>正规集：正规式描述的表达式的集合。<br>对于任意一个正规式，存在定义同一语言的正规文法；反之，对每个正规文法，同样存在一个生成同样语言的正规式。<br>两个正规式等价&lt;=&gt;描述的两个正规集相同（正规式=&gt;NFA=&gt;DFA=&gt;最简化）</p>
<h1 id="第四章-自顶向下的语法分析"><a href="#第四章-自顶向下的语法分析" class="headerlink" title="第四章 自顶向下的语法分析"></a>第四章 自顶向下的语法分析</h1><h2 id="Q11-简述自顶向下的语法分析的基本思想，以及面临主要的问题。"><a href="#Q11-简述自顶向下的语法分析的基本思想，以及面临主要的问题。" class="headerlink" title="Q11.简述自顶向下的语法分析的基本思想，以及面临主要的问题。"></a>Q11.简述自顶向下的语法分析的基本思想，以及面临主要的问题。</h2><p>基本思想：从文发的开始符号出发，往下推导，试图推导出句子。<br>语法树角度：从树根出发，不断向下生长，直至所有叶子构成的串就是句子。<br>面临的两个问题：<br>（1）回溯问题 （2）左递归问题</p>
<h2 id="Q12-FIRST集和FOLLOW集分别表示什么？"><a href="#Q12-FIRST集和FOLLOW集分别表示什么？" class="headerlink" title="Q12.FIRST集和FOLLOW集分别表示什么？"></a>Q12.FIRST集和FOLLOW集分别表示什么？</h2><p>FIRST集：从符号x可以推导出的所有首终结符或可能的ε。<br>FOLLOW集：句型中，紧紧跟在符号A后面的终结符号。</p>
<h2 id="Q13-如何判断有无回溯？"><a href="#Q13-如何判断有无回溯？" class="headerlink" title="Q13.如何判断有无回溯？"></a>Q13.如何判断有无回溯？</h2><p>定义一个SELECT集合：<br>SELECT(x)=FIRST(x)，若ε不属于FIRST(x) / (FIRST(x)-{ε})∪FOLLOW(A)<br>有A-&gt;X1|X2|…|Xn，若SELECT(Xi)∩SELECT(Xj)=Ø，则无回溯</p>
<h2 id="Q14-简述LL-1-分析法的工作原理。"><a href="#Q14-简述LL-1-分析法的工作原理。" class="headerlink" title="Q14.简述LL(1)分析法的工作原理。"></a>Q14.简述LL(1)分析法的工作原理。</h2><p>LL(1)分析技术结构组成包括：栈，输入，输出，总控程序（表驱动），LL(1)分析表<br>（1）若栈顶是非终结符号，查表。空白：报错。否则，栈顶弹出，倒序入栈；<br>（2）若栈顶是终结符号，比较。和下个单词一样：栈顶弹出，读取下一个单词。否则，报错。<br>（3）若栈顶是#，下个单词#，成功。否则，失效报错。</p>
<h1 id="第五章-自底向上的语法分析"><a href="#第五章-自底向上的语法分析" class="headerlink" title="第五章 自底向上的语法分析"></a>第五章 自底向上的语法分析</h1><h2 id="Q15-简述自底向上的语法分析的基本思想，以及面临的主要问题。"><a href="#Q15-简述自底向上的语法分析的基本思想，以及面临的主要问题。" class="headerlink" title="Q15.简述自底向上的语法分析的基本思想，以及面临的主要问题。"></a>Q15.简述自底向上的语法分析的基本思想，以及面临的主要问题。</h2><p>基本思想：从句子出发，不断向上归约，试图归约到文法的开始符号。<br>语法树角度：从叶子开始，向上生长，一直到树根。<br>面临的两个问题：<br>（1）如何寻找可规约子串？<br>（2）找出可规约字串后，用哪一条产生式规则进行规约？</p>
<h2 id="Q16-介绍移进-归约法的基本思想。"><a href="#Q16-介绍移进-归约法的基本思想。" class="headerlink" title="Q16.介绍移进-归约法的基本思想。"></a>Q16.介绍移进-归约法的基本思想。</h2><p>基本思想：不断将下个单词移进栈，判断在栈顶是否已构成一个可规约子串。如果已经构成则立即归约；否则继续移进栈。</p>
<h2 id="Q17-什么是素短语和最左素短语？"><a href="#Q17-什么是素短语和最左素短语？" class="headerlink" title="Q17.什么是素短语和最左素短语？"></a>Q17.什么是素短语和最左素短语？</h2><p>素短语：是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。<br>最左素短语：就是句型最左边的素短语，是算符优先分析法的归约对象。</p>
<h2 id="Q18-简述算符优先分析法的工作原理。"><a href="#Q18-简述算符优先分析法的工作原理。" class="headerlink" title="Q18.简述算符优先分析法的工作原理。"></a>Q18.简述算符优先分析法的工作原理。</h2><p>算符优先分析法从运算符之间优先级的角度作为切入点，通过算符优先关系生成算符优先关系表，就可以在移进-归约过程中，在栈的内部寻找最左素短语，一旦找到就立即进行归约。<br>具体过程：<br>（1）当栈顶运算符优先关系a&lt;b或a=b时，将b移进栈；<br>（2）当栈顶运算符优先关系a&gt;b时，表示已经找到了最左素短语的尾部，然后在栈内由栈顶向栈底搜索第一个出现&lt;的运算符，头尾之间的子串即最左素短语，然后进行归约。</p>
<h2 id="Q19-活前缀的作用是什么？"><a href="#Q19-活前缀的作用是什么？" class="headerlink" title="Q19.活前缀的作用是什么？"></a>Q19.活前缀的作用是什么？</h2><p>如果求出了文法G的所有活前缀，就可以方便地进行语法分析。每当移进一个符号，就查看栈中的内容是否与某一个活前缀βwP相同。若相同则按照规则P进行规约，否则就继续移进下一个符号。</p>
<h2 id="Q20-求优先函数的方法"><a href="#Q20-求优先函数的方法" class="headerlink" title="Q20.求优先函数的方法"></a>Q20.求优先函数的方法</h2><p>（1）Bell有向图法 （2）逐次加1法 （3）Martin算法</p>
<h2 id="Q21-什么是LR-0-项目集规范簇？以及LR-0-项目集中有哪两种冲突形式？"><a href="#Q21-什么是LR-0-项目集规范簇？以及LR-0-项目集中有哪两种冲突形式？" class="headerlink" title="Q21.什么是LR(0)项目集规范簇？以及LR(0)项目集中有哪两种冲突形式？"></a>Q21.什么是LR(0)项目集规范簇？以及LR(0)项目集中有哪两种冲突形式？</h2><p>LR(0)项目集规范簇：能够识别文法G的所有活前缀的LR(0)项目集闭包组成的DFA。<br>两种冲突形式：<br>（1）移进-归约冲突 （2）归约-归约冲突</p>
<h2 id="Q22-相较于LR-0-分析法，SLR-1-分析法如何提高分析能力？"><a href="#Q22-相较于LR-0-分析法，SLR-1-分析法如何提高分析能力？" class="headerlink" title="Q22.相较于LR(0)分析法，SLR(1)分析法如何提高分析能力？"></a>Q22.相较于LR(0)分析法，SLR(1)分析法如何提高分析能力？</h2><p>LR(0)分析技术不向前查看下一个符号，不利用下一个符号的信息。其表现为在填写r型动作时，在ACTION子表的状态i所在行上全填写上归约动作，增加了冲突的机会。<br>SLR(1)分析法通过使用FOLLOW集来提高分析能力，只有下个单词属于某个符号的FOLLOW集时，才允许在表中填入归约动作。</p>
<h2 id="Q23-LR-1-分析技术是如何提高分析能力的？"><a href="#Q23-LR-1-分析技术是如何提高分析能力的？" class="headerlink" title="Q23.LR(1)分析技术是如何提高分析能力的？"></a>Q23.LR(1)分析技术是如何提高分析能力的？</h2><p>当精确指明下个单词是哪些符号时，才允许归约。</p>
<h1 id="第六章-属性文法"><a href="#第六章-属性文法" class="headerlink" title="第六章 属性文法"></a>第六章 属性文法</h1><h2 id="Q24-介绍属性，语义规则以及属性文法的概念。"><a href="#Q24-介绍属性，语义规则以及属性文法的概念。" class="headerlink" title="Q24.介绍属性，语义规则以及属性文法的概念。"></a>Q24.介绍属性，语义规则以及属性文法的概念。</h2><p>属性：对文法中的每个符号，在语义方面人为指派若干个值。<br>语义规则：语法规则中符号属性间存在的约束关系（计算规则）。<br>属性文法：配上语义规则后的文法。</p>
<h2 id="Q25-什么是综合属性，什么是继承属性？"><a href="#Q25-什么是综合属性，什么是继承属性？" class="headerlink" title="Q25.什么是综合属性，什么是继承属性？"></a>Q25.什么是综合属性，什么是继承属性？</h2><p>A -&gt; X1 X2 X3 …Xn相应的语义规则是b=f(a1,a2,…,ak)<br>(1)若b是A的属性：A.b称为A的综合属性；<br>(2)若b是Xi的属性：Xi.b称为Xi的继承属性。<br>综合属性依赖于子结点和自己，在自底向上语法分析时能通过一边扫描全部计算出来；<br>继承属性由其父结点或兄弟结点的属性值来确定，主要用于表达上下文的依赖性。</p>
<h2 id="Q26-什么是S-属性文法，什么是L-属性文法？"><a href="#Q26-什么是S-属性文法，什么是L-属性文法？" class="headerlink" title="Q26.什么是S-属性文法，什么是L-属性文法？"></a>Q26.什么是S-属性文法，什么是L-属性文法？</h2><p>S-属性文法：文法中的所有属性均为综合属性，适合于自底向上的语法分析；<br>L-属性文法：<br>（1）S-属性文法是L-属性文法<br>（2）若A -&gt; X1 X2… Xk…Xn，b是Xk的继承属性，则Xk.b由A的继承属性及左边兄弟的任何属性决定<br>适用于自顶向下的语法分析。</p>
<h2 id="Q27-简述语法制导的语义翻译的基本思想。"><a href="#Q27-简述语法制导的语义翻译的基本思想。" class="headerlink" title="Q27.简述语法制导的语义翻译的基本思想。"></a>Q27.简述语法制导的语义翻译的基本思想。</h2><p>给文法配上语义规则，当进行语法分析，每当发生归约，则自动调用该规则所配置的语义规则。在进行语法分析的同时，自动进行语义的处理，即语义处理的时机，调用何种语义规则都是由当时进行语法分析的归约时刻决定的。</p>
<h2 id="Q28-什么是翻译方案？"><a href="#Q28-什么是翻译方案？" class="headerlink" title="Q28.什么是翻译方案？"></a>Q28.什么是翻译方案？</h2><p>把语义规则转成语义动作，放在规则右部适当位置，成为文法的一个组成部分。</p>
<h2 id="Q29-怎样指导将语义动作插入到合适的位置上？"><a href="#Q29-怎样指导将语义动作插入到合适的位置上？" class="headerlink" title="Q29.怎样指导将语义动作插入到合适的位置上？"></a>Q29.怎样指导将语义动作插入到合适的位置上？</h2><p>（1）继承属性：计算继承属性的动作，应放在符号左边；<br>（2）综合属性：计算综合属性的动作，应放在这样的位置，其他属性都已经算出，通常放在最右边<br>（3）语义动作：一个语义动作不能引用他后边的符号的属性，语义动作通常放在它所引用的属性此时已经全部算出。</p>
<h1 id="第七章-语义分析与语法制导的翻译"><a href="#第七章-语义分析与语法制导的翻译" class="headerlink" title="第七章 语义分析与语法制导的翻译"></a>第七章 语义分析与语法制导的翻译</h1><h2 id="Q30-生成中间代码有什么好处？"><a href="#Q30-生成中间代码有什么好处？" class="headerlink" title="Q30.生成中间代码有什么好处？"></a>Q30.生成中间代码有什么好处？</h2><p>（1）可以进行与具体机器特性无关的能反映代码本身特性的代码优化；<br>（2）当要将编译程序移植到新的目标机器时，前端（词法分析…）几乎不变，只需要修改后端。后端是针对具体目标机器的代码生成与优化。</p>
<h2 id="Q31-简述“回填”技术的思想。"><a href="#Q31-简述“回填”技术的思想。" class="headerlink" title="Q31.简述“回填”技术的思想。"></a>Q31.简述“回填”技术的思想。</h2><p>当生成一个跳转指令时，暂时不指定该跳转指令的目标标号。这样的指令都被放入由跳转指令组成的列表中。同一个列表中的所有跳转指令都具有相同的目标标号。等到能够确定正确的目标标号时，才去填充这些指令的目标标号。</p>
<h1 id="第八章-运行时空间分配"><a href="#第八章-运行时空间分配" class="headerlink" title="第八章 运行时空间分配"></a>第八章 运行时空间分配</h1><h2 id="Q32-说明C语言运行时的空间分配策略。"><a href="#Q32-说明C语言运行时的空间分配策略。" class="headerlink" title="Q32.说明C语言运行时的空间分配策略。"></a>Q32.说明C语言运行时的空间分配策略。</h2><p>对于C语言程序中的全局变量，static型局部变量，采用静态分配存储策略；<br>对于函数中非static型局部变量，采用栈式存储分配策略；<br>对于指针类变量所指的空间，可以通过堆式存储分配策略来管理，需要运行库的支持。<br>运行时内存空间划分为代码区，静态数据去，栈，堆。静态数据区在编译时就已知大小，相对固定；栈和堆大小可变。栈向下生长，堆向上生长。</p>
<h2 id="Q33-什么是活动，什么是活动记录？C语言活动记录的结构是怎样的？"><a href="#Q33-什么是活动，什么是活动记录？C语言活动记录的结构是怎样的？" class="headerlink" title="Q33.什么是活动，什么是活动记录？C语言活动记录的结构是怎样的？"></a>Q33.什么是活动，什么是活动记录？C语言活动记录的结构是怎样的？</h2><p>函数的一次调用执行成为一个活动。<br>从函数的第一条指令开始执行到函数的最后一条指令为止，这个过程为函数的一次活动的生存周期。<br>管理函数的活动所需要的全部信息，称为函数的活动记录。</p>
<p>活动记录结构<br>临时变量<br>局部变量<br>老BP<br>返回地址<br>实参（n）<br>…<br>实参<br>老BP：用于运行时访问局部变量，即实参。格式：[BP+data]。</p>
<h1 id="第九章-代码优化"><a href="#第九章-代码优化" class="headerlink" title="第九章 代码优化"></a>第九章 代码优化</h1><h2 id="Q34-什么是优化？优化原则有什么？"><a href="#Q34-什么是优化？优化原则有什么？" class="headerlink" title="Q34.什么是优化？优化原则有什么？"></a>Q34.什么是优化？优化原则有什么？</h2><p>优化：对程序和中间代码进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。<br>原则：<br>（1）等价原则：不能改变程序运行的结果；<br>（2）有效原则：缩短目标程序运行的时间 / 压缩程序的存储空间<br>（3）合算原则：代价小</p>
<h2 id="Q35-什么是基本块？怎样划分基本块？"><a href="#Q35-什么是基本块？怎样划分基本块？" class="headerlink" title="Q35.什么是基本块？怎样划分基本块？"></a>Q35.什么是基本块？怎样划分基本块？</h2><p>基本块：指程序中一组顺序执行的语句序列，其中只有一个入口和一个出口。入口就是其中的第一条语句，出口就是其最后一条语句。对于一个基本块来说，执行是只能从其入口进入，从其出口退出，期间不能停止也不可能有分支。<br>求入口语句：<br>（1）四元式序列的第一条语句；<br>（2）经条件转移或无条件转移能转到的语句；<br>（3）紧跟在条件转移语句后面的语句<br>对于每个入口语句，其所属的基本块，是由该入口语句到下一入口语句（不包括该入口语句）或到下一转移语句（包括该转移语句）或停语句（包括该停语句）之间的语句序列组成的。</p>
<h2 id="Q36-简述局部优化和循环优化的过程。"><a href="#Q36-简述局部优化和循环优化的过程。" class="headerlink" title="Q36.简述局部优化和循环优化的过程。"></a>Q36.简述局部优化和循环优化的过程。</h2><p>局部优化：（1）准备操作数的结点 （2）合并已知量 （3）删除公共子表达式 （4）删除无用赋值<br>循环优化：（1）代码外提 （2）强度削弱 （3）归纳变量删除</p>
<h2 id="Q37-简述利用DAG图进行基本块优化的基本思想。"><a href="#Q37-简述利用DAG图进行基本块优化的基本思想。" class="headerlink" title="Q37. 简述利用DAG图进行基本块优化的基本思想。"></a>Q37. 简述利用DAG图进行基本块优化的基本思想。</h2><p>基本思想：首先顺序地对一个基本块内所有四元式构造一个DAG，接着按构造节点的次序将DAG还原成四元式序列。构造DAG的同时已经进行了局部优化，因此按照构造DAG结点的顺序，对每一个结点写出相应的四元式就可以实现对基本块的优化处理。</p>
<h1 id="第十章-目标代码生成"><a href="#第十章-目标代码生成" class="headerlink" title="第十章 目标代码生成"></a>第十章 目标代码生成</h1><h2 id="Q38-目标代码生成主要应考虑哪几方面的因素？"><a href="#Q38-目标代码生成主要应考虑哪几方面的因素？" class="headerlink" title="Q38.目标代码生成主要应考虑哪几方面的因素？"></a>Q38.目标代码生成主要应考虑哪几方面的因素？</h2><p>目标代码可以是某种能立即执行的机器语言代码，也可以是可重定位的机器语言模块，或者是某种类型机器上的汇编语言程序。<br>目标代码生成主要考虑的因素包括：生成的代码要短，执行效率高（充分利用机器中的寄存器，使用指令代价小的指令等）。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1.什么是数据库？"></a>1.什么是数据库？</h2><p>  数据库是一个庞大的、集成的数据集合；它是对现实世界企业的建模，数据库包含实体与联系</p>
<h2 id="2-什么是关系数据模型？"><a href="#2-什么是关系数据模型？" class="headerlink" title="2.什么是关系数据模型？"></a>2.什么是关系数据模型？</h2><p>  关系数据模型是一种利用表的集合来表示数据和数据间的联系的数据模型</p>
<h2 id="3-数据抽象的三个层次是什么？"><a href="#3-数据抽象的三个层次是什么？" class="headerlink" title="3.数据抽象的三个层次是什么？"></a>3.数据抽象的三个层次是什么？</h2><p>  数据抽象的三个层次从低到高分别是物理层、逻辑层与视图层；<br>  物理层是最低层次的抽象，描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构<br>  逻辑层是比物理层层次稍高的抽象，描述数据库中存储什么数据及这些数据间存在什么关系。<br>  视图层是最高层次的抽象，只描述整个数据库的某个部分，用于与用户的交互</p>
<h2 id="4-什么是数据独立性？"><a href="#4-什么是数据独立性？" class="headerlink" title="4.什么是数据独立性？"></a>4.什么是数据独立性？</h2><p>  数据独立性包括逻辑数据独立性与物理数据独立性，逻辑数据独立性指应用程序不受数据逻辑结构变化的影响。物理数据独立性指应用程序不受数据物理存储结构变化的影响</p>
<h2 id="5-什么是数据库的三级模式结构？"><a href="#5-什么是数据库的三级模式结构？" class="headerlink" title="5.什么是数据库的三级模式结构？"></a>5.什么是数据库的三级模式结构？</h2><p>  数据库的三级模式结构包括外模式、概念模式（模式）、内模式<br>  外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图<br>  概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述<br>  内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库</p>
<h2 id="6-数据库设计可分为哪几个阶段？"><a href="#6-数据库设计可分为哪几个阶段？" class="headerlink" title="6.数据库设计可分为哪几个阶段？"></a>6.数据库设计可分为哪几个阶段？</h2><p>  数据库设计可分为需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行与维护这几个阶段</p>
<h2 id="7-为什么不用文件处理系统来存储组织信息，而是用数据库系统？"><a href="#7-为什么不用文件处理系统来存储组织信息，而是用数据库系统？" class="headerlink" title="7.为什么不用文件处理系统来存储组织信息，而是用数据库系统？"></a>7.为什么不用文件处理系统来存储组织信息，而是用数据库系统？</h2><p>  使用文件处理系统来存储组织信息的主要弊端包括：数据的冗余和不一致、数据访问困难、数据孤立、完整性问题、原子性问题、并发访问异常问题以及安全性问题。以上问题促进了数据库系统的发展，数据库系统为了解决上述问题提出了大量的概念和算法</p>
<h2 id="8-SQL语句按照功能可分为哪几个部分？"><a href="#8-SQL语句按照功能可分为哪几个部分？" class="headerlink" title="8.SQL语句按照功能可分为哪几个部分？"></a>8.SQL语句按照功能可分为哪几个部分？</h2><p>  SQL语句按功能可分为数据定义语言DDL、查询语言QL、数据操纵语言DML、数据控制语言DCL<br>  数据定义语言用于定义，删除或更改数据模式。查询语言用于检索数据。数据操纵语言用于插入、删除或更新数据。数据控制语言用于控制用户对数据的访问权限</p>
<h1 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h1><h2 id="1-在数据库发展的历史中，总共出现过哪些数据模型？"><a href="#1-在数据库发展的历史中，总共出现过哪些数据模型？" class="headerlink" title="1.在数据库发展的历史中，总共出现过哪些数据模型？"></a>1.在数据库发展的历史中，总共出现过哪些数据模型？</h2><p>  数据模型的发展大致经历了层次数据模型、网状数据模型、关系数据模型、实体-联系模型、面向对象的数据模型等过程</p>
<h2 id="2-关系数据模型中的关系指的是什么？"><a href="#2-关系数据模型中的关系指的是什么？" class="headerlink" title="2.关系数据模型中的关系指的是什么？"></a>2.关系数据模型中的关系指的是什么？</h2><p>  在关系模型的术语中，关系用来指表，元组用来指行，属性指代的是表中的列</p>
<h2 id="3-为什么关系数据模型是目前使用最广泛的数据模型？"><a href="#3-为什么关系数据模型是目前使用最广泛的数据模型？" class="headerlink" title="3.为什么关系数据模型是目前使用最广泛的数据模型？"></a>3.为什么关系数据模型是目前使用最广泛的数据模型？</h2><p>  关系数据模型基于集合论，具有很高的抽象级别，它建立了新的代数系统——关系代数，它可以支持非过程化的查询语言——SQL语言。</p>
<h2 id="4-什么是主键？"><a href="#4-什么是主键？" class="headerlink" title="4.什么是主键？"></a>4.什么是主键？</h2><p>  一组属性是关系的候选键，如果任意两条不同元组在这组属性上的值都不同，或者这组属性的值确定，该元组其他属性的值被唯一确定。<br>  若这组属性的任何一个子集没有上述特性，则可从中选取一个键作为主键，其他的则称为候选键。</p>
<h2 id="5-什么是外键？"><a href="#5-什么是外键？" class="headerlink" title="5.什么是外键？"></a>5.什么是外键？</h2><p>  外键是一个关系中用于引用另一个关系中的元组的属性集，它是通过另一个关系的主键来引用该关系的</p>
<h2 id="6-关系代数的基本操作有哪些？"><a href="#6-关系代数的基本操作有哪些？" class="headerlink" title="6.关系代数的基本操作有哪些？"></a>6.关系代数的基本操作有哪些？</h2><p>  选择、投影、笛卡尔乘积、集合差、集合并是关系代数的基本操作，它们是一组完备操作集合，其他关系代数的操作都可由它们派生出来</p>
<h1 id="1-3-数据库设计"><a href="#1-3-数据库设计" class="headerlink" title="1.3 数据库设计"></a>1.3 数据库设计</h1><h2 id="1-什么是1NF、2NF、3NF、4NF、5NF？"><a href="#1-什么是1NF、2NF、3NF、4NF、5NF？" class="headerlink" title="1.什么是1NF、2NF、3NF、4NF、5NF？"></a>1.什么是1NF、2NF、3NF、4NF、5NF？</h2><p>  1NF指关系的每个属性都必须是原子的，2NF在1NF的基础上加上了不允许属性对主键的部分函数依赖这一项，3NF在2NF的基础上加上了不允许属性对主键的传递函数依赖这一项<br>  4NF在3NF的基础上消除了可能存在的属性之间的多值依赖，5NF在4NF的基础上消除了可能存在的连接依赖<br>  一般的标准是需要满足3NF</p>
<h2 id="2-有哪些数据依赖关系？"><a href="#2-有哪些数据依赖关系？" class="headerlink" title="2.有哪些数据依赖关系？"></a>2.有哪些数据依赖关系？</h2><p>  属性之间存在的依赖关系有：函数依赖、多值依赖、连接依赖<br>  函数依赖是一种最基本的数据依赖关系，它是指一个或一组属性的值可以决定其他属性的值，函数依赖是多值依赖的特例<br>  多值依赖是指一些属性的值可以决定其他一些属性的一组值<br>  连接依赖是指，如果可以始终通过连接多个表（每个表都具有T的属性的子集）来重新创建T，则表T受到连接依赖性的约束。</p>
<h2 id="3-数据库设计采用的方法有哪几种？"><a href="#3-数据库设计采用的方法有哪几种？" class="headerlink" title="3.数据库设计采用的方法有哪几种？"></a>3.数据库设计采用的方法有哪几种？</h2><p>  数据库设计采用的方法有面向过程的方法和面向数据的方法两种类型<br>  面向过程的方法以业务流程为中心，由于没有对数据以及数据之间的内部关系进行详细的分析，尽管完成项目需要的时间较短，但是很难确保软件质量，而且系统也很难适应未来的需求和环境变化。 这种方法不适用于大型复杂系统的开发<br>  面向数据的方法基于对数据的详细分析和数据之间的内在联系来设计数据库。它以数据为中心，而不是以业务流程为中心。它不仅可以满足当前的需求，还可以满足一些未来潜在的需求，易于适应需求和环境的变化。此方法适合在开发大型，复杂的系统时使用。</p>
<h1 id="1-4-数据存储和查询"><a href="#1-4-数据存储和查询" class="headerlink" title="1.4 数据存储和查询"></a>1.4 数据存储和查询</h1><h2 id="1-文件中记录的组织形式有哪几种？"><a href="#1-文件中记录的组织形式有哪几种？" class="headerlink" title="1.文件中记录的组织形式有哪几种？"></a>1.文件中记录的组织形式有哪几种？</h2><p>  有堆文件形式、哈希文件形式、索引文件形式、动态哈希文件形式等<br>  在堆文件中，记录按照插入顺序存储，并按顺序检索。这是文件组织中最基本，最通用的形式<br>  在哈希文件中，使用每条记录的某些属性计算一个散列函数，散列函数的结果确定了记录应放到文件的哪个块中<br>  索引文件则在堆文件的基础上使用了B+树索引<br>  动态哈希文件可以动态调整哈希函数的映射空间</p>
<h2 id="2-查询优化可以在哪两个方面进行？"><a href="#2-查询优化可以在哪两个方面进行？" class="headerlink" title="2.查询优化可以在哪两个方面进行？"></a>2.查询优化可以在哪两个方面进行？</h2><p>  查询优化一方面在关系代数级别发生，即系统尝试找出一个与给出的表达式等价但执行起来更为高效的表达式。另一方面是为处理查询选择一个详细的策略，比如对一个操作的执行选择合适的算法，选择使用特定的索引等</p>
<h1 id="1-5-事务管理"><a href="#1-5-事务管理" class="headerlink" title="1.5 事务管理"></a>1.5 事务管理</h1><h2 id="1-什么是事务？事务具有的特性是什么？每个特性的含义分别是什么？"><a href="#1-什么是事务？事务具有的特性是什么？每个特性的含义分别是什么？" class="headerlink" title="1.什么是事务？事务具有的特性是什么？每个特性的含义分别是什么？"></a>1.什么是事务？事务具有的特性是什么？每个特性的含义分别是什么？</h2><p>  事务是访问并可能更新各种数据项的一个程序执行单元。事务具有ACID特性：原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。<br>  原子性保证事务的所有影响在数据库中要么全部反映出来，要么根本不反映；一个故障不能让数据库处于事务部分执行后的状态<br>  一致性保证若数据库一开始是一致的，则事务（单独）执行后数据库仍处于一致状态<br>  隔离性保证并发执行的事务相互隔离，使得每个事务感觉不到系统中其他事务的并发执行<br>  持久性保证一旦一个事务提交后，它对数据库的改变不会丢失，即使系统可能出现故障</p>
<h2 id="2-什么是两阶段封锁协议，两阶段封锁协议可以保证不会发生死锁吗？有哪些应对死锁的方式？"><a href="#2-什么是两阶段封锁协议，两阶段封锁协议可以保证不会发生死锁吗？有哪些应对死锁的方式？" class="headerlink" title="2.什么是两阶段封锁协议，两阶段封锁协议可以保证不会发生死锁吗？有哪些应对死锁的方式？"></a>2.什么是两阶段封锁协议，两阶段封锁协议可以保证不会发生死锁吗？有哪些应对死锁的方式？</h2><p>  两阶段封锁协议要求每个事务分两个阶段提出加锁和解锁申请，这两个阶段分别是增长阶段和缩减阶段。在增长阶段，事务可以获得锁，但不能释放锁；在缩减阶段，事务可以释放锁，但不能获得新锁<br>  两阶段封锁并不能保证不会发生死锁<br>  处理死锁问题主要有两种方式，分别是死锁预防和死锁检测与恢复。预防死锁有两种方法：一种方法是通过对加锁请求进行排序或要求同时获得所有的锁来保证不会发生循环等待。另一种方法比较接近死锁恢复，每当等待有可能导致死锁时，进行事务回滚而不是等待加锁。死锁检测则根据等待图进行，当检测算法判定存在死锁时，需根据回滚代价选择某一个（或一些）事务进行回滚</p>
<h2 id="3-什么是日志？"><a href="#3-什么是日志？" class="headerlink" title="3.什么是日志？"></a>3.什么是日志？</h2><p>  日志是自上次备份副本以来，数据库上所有更新的记录</p>
<h2 id="4-什么是提交规则、先记后写规则？"><a href="#4-什么是提交规则、先记后写规则？" class="headerlink" title="4.什么是提交规则、先记后写规则？"></a>4.什么是提交规则、先记后写规则？</h2><p>  提交规则是指在提交事务之前，必须将新值写入非易失性存储器。先记后写规则是指如果在事务提交之前将新值写入数据库，则必须在此之前先将旧值写入日志</p>
<h2 id="5-当数据库中有多个事务并发执行时，有可能出现哪些问题？如何解决这些问题？"><a href="#5-当数据库中有多个事务并发执行时，有可能出现哪些问题？如何解决这些问题？" class="headerlink" title="5.当数据库中有多个事务并发执行时，有可能出现哪些问题？如何解决这些问题？"></a>5.当数据库中有多个事务并发执行时，有可能出现哪些问题？如何解决这些问题？</h2><p>  当数据库中有多个事务并发执行时，有可能出现丢失更新（写-写冲突）、脏读（写-读冲突）、不可重复的读（读-写冲突）。写-写冲突在任何时候都应该被避免，写-读和读-写冲突在通常情况下应该被避免，但它们在某些应用场合下可以存在。<br>  最常用的并发控制机制有两阶段封锁协议和快照隔离</p>
<h2 id="6-有哪些检测死锁发生的方式？在何时检测死锁是否发生？在检测出死锁发生后，如何解除死锁？"><a href="#6-有哪些检测死锁发生的方式？在何时检测死锁是否发生？在检测出死锁发生后，如何解除死锁？" class="headerlink" title="6.有哪些检测死锁发生的方式？在何时检测死锁是否发生？在检测出死锁发生后，如何解除死锁？"></a>6.有哪些检测死锁发生的方式？在何时检测死锁是否发生？在检测出死锁发生后，如何解除死锁？</h2><p>  检测死锁是否发生的一种方法是：若某事务等待了指定的时间，则认为发生死锁，并中止该事务。另一种方法是利用等待图来检测死锁，若等待图中有环，则死锁发生。<br>  检测死锁常用的方式是周期性检测，也可以在某个事务等待时进行检测<br>  解除死锁首先需根据回滚代价选择一个事务作为牺牲者，然后回滚该事务并释放它拥有的所有资源和锁，接下来允许一个等待事务运行，最后重启被回滚的事务</p>
<h2 id="7-如何使用基于时间戳的协议进行死锁避免？"><a href="#7-如何使用基于时间戳的协议进行死锁避免？" class="headerlink" title="7.如何使用基于时间戳的协议进行死锁避免？"></a>7.如何使用基于时间戳的协议进行死锁避免？</h2><p>  每个事务都有其唯一的时间戳，若A事务请求对已经被B事务加锁的数据对象加锁，则等待-死亡方法或击伤-等待方法其中之一将被使用以避免死锁的发生<br>  在等待-死亡方法下，若A的时间戳小于B，则A等待，否则它将被回滚并进入睡眠，之后自动地使用原来的时间戳重新运行<br>  在击伤-等待方法下，若A的时间戳大于B，则A等待，否则它将B击伤，即事务B被回滚并进入睡眠，之后自动地使用原来的时间戳重新运行<br>  在上述两种方法下，都只会出现单方向等待，不会出现循环等待，因此死锁被避免</p>
<p>2.编译原理</p>
<h1 id="2-1-引论"><a href="#2-1-引论" class="headerlink" title="2.1 引论"></a>2.1 引论</h1><h2 id="1-从高级语言源程序到目标机器代码的全过程是怎样的？"><a href="#1-从高级语言源程序到目标机器代码的全过程是怎样的？" class="headerlink" title="1.从高级语言源程序到目标机器代码的全过程是怎样的？"></a>1.从高级语言源程序到目标机器代码的全过程是怎样的？</h2><p>  源程序首先要经过预处理器，预处理器将存储在不同文件中的源程序聚合在一起，并把宏转换为原始语句。经过预处理后的源程序交与编译器，编译器将其编译为汇编语言程序，汇编语言程序之后被汇编器汇编为可重定位的机器代码，该机器代码经由链接器以及加载器处理后变为最终的目标机器代码</p>
<h2 id="2-编译程序的工作包括哪些方面？它们具体的含义是什么？"><a href="#2-编译程序的工作包括哪些方面？它们具体的含义是什么？" class="headerlink" title="2.编译程序的工作包括哪些方面？它们具体的含义是什么？"></a>2.编译程序的工作包括哪些方面？它们具体的含义是什么？</h2><p>  编译程序的工作包括：词法分析、语法分析、语义分析和中间代码生成、优化以及目标代码生成<br>  词法分析的任务是扫描源程序的字符，识别出各个单词，确定单词的类型，将识别出的单词转换成统一的机内表示（词法单元token形式）<br>  语法分析从词法分析器输出的token序列中识别出各类短语，并构造语法分析树，语法分析树描述了句子的语法结构<br>  语义分析的任务是收集标识符的属性信息并进行语义检查<br>  中间代码生成的任务是对语法分析识别出的各类语法范畴，分析其含义，进行初步翻译，产生介于源代码和目标代码之间的一种代码<br>  优化的任务是对中间代码进行加工变换，为的是在最后阶段能产生更为高效的目标代码<br>  目标代码生成的任务是把经过优化的中间代码转化成特定机器上的低级语言代码</p>
<h2 id="3-什么是终结符、什么是非终结符"><a href="#3-什么是终结符、什么是非终结符" class="headerlink" title="3.什么是终结符、什么是非终结符?"></a>3.什么是终结符、什么是非终结符?</h2><p>  终结符是文法所定义的语言的基本符号，有时也称为token<br>  非终结符是用来表示语法成分的符号，有时也称为语法变量</p>
<h1 id="2-2-词法分析"><a href="#2-2-词法分析" class="headerlink" title="2.2 词法分析"></a>2.2 词法分析</h1><h2 id="1-什么是正则表达式？"><a href="#1-什么是正则表达式？" class="headerlink" title="1.什么是正则表达式？"></a>1.什么是正则表达式？</h2><p>  正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<h2 id="2-什么是有穷自动机、确定有穷自动机、不确定有穷自动机"><a href="#2-什么是有穷自动机、确定有穷自动机、不确定有穷自动机" class="headerlink" title="2.什么是有穷自动机、确定有穷自动机、不确定有穷自动机?"></a>2.什么是有穷自动机、确定有穷自动机、不确定有穷自动机?</h2><p>  有穷自动机是对一类处理系统建立的数学模型，这类系统具有一系列离散的输入输出信息和有穷数目的内部状态。系统只需要根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入后，系统的内部状态也将发生改变<br>  确定有穷自动机是一种特殊的有穷自动机，它的任意一个状态对于任意一个输入符号有且只有一个转换。<br>  不确定有穷自动机是说当一个状态面对一个输入符号的时候，它所转换到的可能不只一个状态，可以是一个状态集合</p>
<h2 id="3-什么是有穷自动机定义的语言？"><a href="#3-什么是有穷自动机定义的语言？" class="headerlink" title="3.什么是有穷自动机定义的语言？"></a>3.什么是有穷自动机定义的语言？</h2><p>  给定输入串x，若存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该有穷自动机接收<br>  由一个有穷自动机接收的所有串构成的集合称为是该有穷自动机定义的语言</p>
<h2 id="4-词法分析阶段可以检测到哪些错误类型？是如何检测的？对错误的处理过程是什么？"><a href="#4-词法分析阶段可以检测到哪些错误类型？是如何检测的？对错误的处理过程是什么？" class="headerlink" title="4.词法分析阶段可以检测到哪些错误类型？是如何检测的？对错误的处理过程是什么？"></a>4.词法分析阶段可以检测到哪些错误类型？是如何检测的？对错误的处理过程是什么？</h2><p>  词法分析阶段可以检测到的错误类型有：单词拼写错误、非法字符。<br>  词法错误检测的方法是：若当前状态与当前输入符号在转换表对应项中的信息为空，则报错，调用错误处理程序<br>  错误处理程序将查找已扫描字符串中最后一个对应于某终态的字符，若找到，将该字符与其前面的字符识别成一个单词，然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词。若未找到，则确定出错，采用错误恢复策略。<br>  简单的一种错误恢复策略称为恐慌模式，它从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止</p>
<h1 id="2-3-语法分析"><a href="#2-3-语法分析" class="headerlink" title="2.3 语法分析"></a>2.3 语法分析</h1><h2 id="1-什么是上下文无关文法？"><a href="#1-什么是上下文无关文法？" class="headerlink" title="1.什么是上下文无关文法？"></a>1.什么是上下文无关文法？</h2><p>  上下文无关文法就是说这个文法中所有的产生式左边只有一个非终结符</p>
<h2 id="2-什么是语法分析树？"><a href="#2-什么是语法分析树？" class="headerlink" title="2.什么是语法分析树？"></a>2.什么是语法分析树？</h2><p>  一颗语法分析树是一个推导的图形表示。在推导中出现的每一个非终结符号都在树中有一个对应结点。一个结点的子节点就是在推导中用来替换该节点对应的非终结符号的文法符号串。</p>
<h2 id="3-什么是二义性文法？"><a href="#3-什么是二义性文法？" class="headerlink" title="3.什么是二义性文法？"></a>3.什么是二义性文法？</h2><p>  若一个文法的某些终结符号串有两颗或多颗语法分析树，或者等价地说有两个或多个最左推导/最右推导，那么这个文法就称为二义性文法。在实践中的大多数情况下，我们可以对一个二义性文法进行重新设计，使它变成一个描述相同语言的无二义性文法。然而，有时使用二义性文法并应用一些技巧可以得到更加高效的语法分析器</p>
<h2 id="4-什么是自顶向下和自底向上语法分析？"><a href="#4-什么是自顶向下和自底向上语法分析？" class="headerlink" title="4.什么是自顶向下和自底向上语法分析？"></a>4.什么是自顶向下和自底向上语法分析？</h2><p>  语法分析器通常可以按照它们的工作方式分为自顶向下的（从文法的开始符号出发，从顶部开始构造语法分析树）和自底向上的（从构成语法分析树叶子节点的终结符号串开始，从底部开始构造语法分析树）。自顶向下的语法分析器包括递归下降语法分析器和LL语法分析器，而最常见的自底向上语法分析器是LR语法分析器</p>
<h2 id="5-什么是推导？什么是归约？什么是最左推导？什么是最右推导？自底向上的分析和自顶向下的分析分别采用什么推导或归约方式？"><a href="#5-什么是推导？什么是归约？什么是最左推导？什么是最右推导？自底向上的分析和自顶向下的分析分别采用什么推导或归约方式？" class="headerlink" title="5.什么是推导？什么是归约？什么是最左推导？什么是最右推导？自底向上的分析和自顶向下的分析分别采用什么推导或归约方式？"></a>5.什么是推导？什么是归约？什么是最左推导？什么是最右推导？自底向上的分析和自顶向下的分析分别采用什么推导或归约方式？</h2><p>  推导是从开始符号开始，通过使用产生式的右部取代左部，最终能产生语言的一个句子的过程。在最左推导中，总是选择每个句型的最左非终结符进行替换，在最右推导中，总是选择每个句型的最右非终结符进行替换<br>  归约是推导的逆过程，即从给定的源语言的句子开始，通过规则的左部取代右部，最终达到开始符号的过程<br>  自底向上的分析采用最左归约的方式，自顶向下的语法分析采用最左推导方式</p>
<h1 id="2-4-语法制导的翻译"><a href="#2-4-语法制导的翻译" class="headerlink" title="2.4 语法制导的翻译"></a>2.4 语法制导的翻译</h1><h2 id="1-语法制导翻译指的是编译的哪几个阶段？"><a href="#1-语法制导翻译指的是编译的哪几个阶段？" class="headerlink" title="1.语法制导翻译指的是编译的哪几个阶段？"></a>1.语法制导翻译指的是编译的哪几个阶段？</h2><p>  语法制导翻译包括语法分析、语义分析、中间代码生成三个阶段<br>  语法制导翻译使用上下文无关文法（CFG）来引导对语言的翻译，是一种面向文法的翻译技术</p>
<h1 id="2-5-中间代码生成"><a href="#2-5-中间代码生成" class="headerlink" title="2.5 中间代码生成"></a>2.5 中间代码生成</h1><p>  1.常见的中间代码形式有哪些？<br>  四元式、三元式、逆波兰式</p>
<h1 id="2-6-运行时刻环境"><a href="#2-6-运行时刻环境" class="headerlink" title="2.6 运行时刻环境"></a>2.6 运行时刻环境</h1><h2 id="1-数据的存储分配策略是怎样的？"><a href="#1-数据的存储分配策略是怎样的？" class="headerlink" title="1.数据的存储分配策略是怎样的？"></a>1.数据的存储分配策略是怎样的？</h2><p>  对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为静态存储分配。反之，若不能在编译时完全确定数据对象的大小，就要采用动态存储分配的策略，即在编译时仅产生各种必要的信息，而在运行时刻，再动态地分配数据对象的存储空间。动态存储分配又可分为栈式存储分配与堆式存储分配<br>  静态和动态存储分配分别对应编译时刻和运行时刻</p>
<h2 id="2-程序运行时内存的划分是怎样的？"><a href="#2-程序运行时内存的划分是怎样的？" class="headerlink" title="2.程序运行时内存的划分是怎样的？"></a>2.程序运行时内存的划分是怎样的？</h2><p>  内存分为静态代码区、静态数据区以及动态数据区。动态数据区又分为栈区、堆区以及空闲内存区</p>
<h2 id="3-适合静态存储分配的语言必须满足的限制条件是什么？常用的静态存储分配方法有哪些？"><a href="#3-适合静态存储分配的语言必须满足的限制条件是什么？常用的静态存储分配方法有哪些？" class="headerlink" title="3.适合静态存储分配的语言必须满足的限制条件是什么？常用的静态存储分配方法有哪些？"></a>3.适合静态存储分配的语言必须满足的限制条件是什么？常用的静态存储分配方法有哪些？</h2><p>  适合静态存储分配的语言必须满足：数组上下界必须是常数、不允许过程的递归调用以及不允许动态建立数据实体<br>  常用的静态存储分配方法有：顺序分配法、层次分配法。顺序分配法按照过程出现的先后顺序逐段分配存储空间，各过程的活动记录占用互不相交的存储空间。层次分配法通过对过程间的调用关系进行分析，凡属无相互调用关系的并列过程，尽量使其局部数据共享存储空间</p>
<h2 id="4-什么是栈式存储分配？"><a href="#4-什么是栈式存储分配？" class="headerlink" title="4.什么是栈式存储分配？"></a>4.什么是栈式存储分配？</h2><p>  有些语言使用过程、函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的编译器都把它们的运行时刻存储以栈的形式进行管理，称为栈式存储分配<br>  这种安排不仅允许活跃时段不交叠的多个过程调用之间共享空间，而且使得过程的非局部变量的相对地址总是固定的，和过程调用序列无关</p>
<h1 id="2-7-代码生成"><a href="#2-7-代码生成" class="headerlink" title="2.7 代码生成"></a>2.7 代码生成</h1><h2 id="1-什么是流图？"><a href="#1-什么是流图？" class="headerlink" title="1.什么是流图？"></a>1.什么是流图？</h2><p>  流图是程序的一种图形化表示方式。其中图的结点是基本块，而图的边显示了控制流如何在基本块之间流动</p>
<h2 id="2-什么是窥孔优化？"><a href="#2-什么是窥孔优化？" class="headerlink" title="2.什么是窥孔优化？"></a>2.什么是窥孔优化？</h2><p>  窥孔是程序上的一个小的滑动窗口，窥孔优化是指在优化的时候，检查目标指令的一个滑动窗口（即窥孔），并且只要有可能就在窥孔内用更快或更短的指令来替换窗口中的指令序列</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Jok Brown
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.likepanda.cn/2023/03/14/compiler/" title="compiler">http://www.likepanda.cn/2023/03/14/compiler/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/03/15/network/" rel="prev" title="network">
                  <i class="fa fa-chevron-left"></i> network
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/14/question/" rel="next" title="question">
                  question <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jok Brown</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>



  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
