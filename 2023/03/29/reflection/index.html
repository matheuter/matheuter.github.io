<!DOCTYPE html>
<html lang="zh-CH">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#fffff1"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#fffff1">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.likepanda.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":10,"offset":5},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Metaclasses and Reflection in C++© Copyright 2000, Detlef Vollmann PrefaceOver the last two years I’ve held several tutorials on meta-classes and reflection in C++. I use the term reflection here in">
<meta property="og:type" content="article">
<meta property="og:title" content="reflection">
<meta property="og:url" content="http://www.likepanda.cn/2023/03/29/reflection/index.html">
<meta property="og:site_name" content="rivia site">
<meta property="og:description" content="Metaclasses and Reflection in C++© Copyright 2000, Detlef Vollmann PrefaceOver the last two years I’ve held several tutorials on meta-classes and reflection in C++. I use the term reflection here in">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig1.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig2.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig3.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig4.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig5.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig6.jpg">
<meta property="og:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig7.jpg">
<meta property="article:published_time" content="2023-03-29T11:54:05.000Z">
<meta property="article:modified_time" content="2023-03-29T11:58:06.677Z">
<meta property="article:author" content="Jok Brown">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.likepanda.cn/2023/03/29/reflection/fig1.jpg">


<link rel="canonical" href="http://www.likepanda.cn/2023/03/29/reflection/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CH","comments":true,"permalink":"http://www.likepanda.cn/2023/03/29/reflection/","path":"2023/03/29/reflection/","title":"reflection"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>reflection | rivia site</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">rivia site</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">deep thinking</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于rivia</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>博客归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索本站
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Metaclasses-and-Reflection-in-C"><span class="nav-number">1.</span> <span class="nav-text">Metaclasses and Reflection in C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preface"><span class="nav-number">1.1.</span> <span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.2.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-simple-story"><span class="nav-number">1.3.</span> <span class="nav-text">A simple story</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Meta-Classes-for-C"><span class="nav-number">1.4.</span> <span class="nav-text">Meta Classes for C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MOP-Overview"><span class="nav-number">1.4.1.</span> <span class="nav-text">MOP Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type"><span class="nav-number">1.4.2.</span> <span class="nav-text">Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute"><span class="nav-number">1.4.3.</span> <span class="nav-text">Attribute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Classes"><span class="nav-number">1.4.4.</span> <span class="nav-text">Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Values"><span class="nav-number">1.4.5.</span> <span class="nav-text">Values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RealValue"><span class="nav-number">1.4.6.</span> <span class="nav-text">RealValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value-handle"><span class="nav-number">1.4.7.</span> <span class="nav-text">Value handle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">1.4.8.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Setting-the-values-for-the-objects"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">Setting the values for the objects:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Getting-the-values"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">Getting the values:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflection-for-existing-C-classes"><span class="nav-number">1.5.</span> <span class="nav-text">Reflection for existing C++ classes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pointer-to-member"><span class="nav-number">1.5.1.</span> <span class="nav-text">Pointer to member</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pointer-to-member-Types"><span class="nav-number">1.5.2.</span> <span class="nav-text">pointer-to-member Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-classes"><span class="nav-number">1.5.3.</span> <span class="nav-text">C++ classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-objects"><span class="nav-number">1.5.4.</span> <span class="nav-text">C++ objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Usage"><span class="nav-number">1.5.5.</span> <span class="nav-text">Usage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Interface"><span class="nav-number">1.5.6.</span> <span class="nav-text">C++ Interface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applications"><span class="nav-number">1.6.</span> <span class="nav-text">Applications</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Two-final-remarks"><span class="nav-number">1.7.</span> <span class="nav-text">Two final remarks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coming-articles"><span class="nav-number">1.8.</span> <span class="nav-text">Coming articles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">1.9.</span> <span class="nav-text">References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Notes"><span class="nav-number">1.10.</span> <span class="nav-text">Notes</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jok Brown</p>
  <div class="site-description" itemprop="description">python c++ qt</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CH">
    <link itemprop="mainEntityOfPage" href="http://www.likepanda.cn/2023/03/29/reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jok Brown">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rivia site">
      <meta itemprop="description" content="python c++ qt">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="reflection | rivia site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          reflection
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-03-29 19:54:05 / 修改时间：19:58:06" itemprop="dateCreated datePublished" datetime="2023-03-29T19:54:05+08:00">2023-03-29</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h1 id="Metaclasses-and-Reflection-in-C"><a href="#Metaclasses-and-Reflection-in-C" class="headerlink" title="Metaclasses and Reflection in C++"></a>Metaclasses and Reflection in C++</h1><p>© Copyright 2000, Detlef Vollmann</p>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>Over the last two years I’ve held several tutorials on meta-classes and reflection in C++. I use the term reflection here in its original sense, “looking back to oneself”, nowadays sometimes called introspection. The more general process to allow modifications at class level at run-time is the old task to provide a meta-level, but is today sometimes (mis-)called “behavioural reflection” or “structural reflection”.</p>
<p>In some sense this article presents work in progress, though it’s going on now for nearly ten years. It’s not the definitive meta-object protocol for C++, but more a presentation of lesser-known C++ techniques to solve some specific design problems.</p>
<p>If you have comments on these techniques, or proposals how the problems could be solved completely differently, or if you find errors in this article, I really appreciate your feedback to <a href="mailto:dv@vollmann.ch">dv@vollmann.ch</a>.</p>
<p>This document can be found on the web at <a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/index.html">http://www.vollmann.com/en/pubs/meta/index.html</a>.</p>
<p>Some source code to illustrate the implementation of the ideas of this article can be found at <a target="_blank" rel="noopener" href="http://www.vollmann.com/download/mop/index.html">http://www.vollmann.com/download/mop/index.html</a>.</p>
<p>The code in this article is not completely identical with that source code (due to typographical reasons and compiler restrictions). So, it could well be that some errors crept into the code here; if you find them, please mail me as well.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>C++ is a strongly typed compiler language. Though not as strongly typed as ADA, a C++ compiler will complain if you try to assign an object of one type to an object of another type (if there is no acceptable conversion). Obviously, this requires that the compiler knows all available types. More specifically, all classes must be known at compile-time<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn1">1</a>. But sometimes, it would be quite handy to add new classes at runtime. And in some application domains, this is absolutely necessary.</p>
<h2 id="A-simple-story"><a href="#A-simple-story" class="headerlink" title="A simple story"></a>A simple story</h2><p>Let’s look at a simple example: Susan, the manager of a local bookstore, wants to expand into the Internet. So she asks you to write a simple program for an Internet bookshop. No problem for you. Part of your solution will probably look like the class model in Fig. 1.<br><img src="/2023/03/29/reflection/fig1.jpg" alt="Fig. 1: Simple Shop Model"><br>Fig. 1: Simple Shop Model</p>
<p>The implementation of this in C++ is straightforward. Here is the <code>Book</code> class:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">string</span> &amp; author_,</span><br><span class="line">         <span class="keyword">const</span> <span class="built_in">string</span> &amp; title_,</span><br><span class="line">         <span class="keyword">const</span> <span class="built_in">string</span> &amp; publisher_,</span><br><span class="line">         <span class="built_in">double</span> price_,</span><br><span class="line">         <span class="built_in">double</span> weight_);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line">        <span class="keyword">return</span> name.substr(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">getPrice</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">getWeight</span>()</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> author, title, publisher;</span><br><span class="line">    <span class="built_in">double</span> price, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Your solution works, Susan is happy, and all is fine for a while…<br>But changes come on the Web in Internet time: the bookshop is a success and Susan decides to sell CDs as well. So you have to change your program. With object orientation, you can do this quite easily and your modified class model will look like Fig. 2.<br><img src="/2023/03/29/reflection/fig2.jpg" alt="Fig. 2: Product Model"><br>Fig. 2: Product Model</p>
<p>As you probably guessed, this was only the beginning. Some time later, Susan wants to sell Pop music accessories like T-shirts, posters, etc. as well.<br>Now it is clear that it is not acceptable to modify the source code of your program every time a new product category is introduced. So you start to think about the actual requirements, and find that you need to provide different interfaces for your <code>Product</code> class (Fig. 3): A simple interface for <code>ShoppingCart</code> providing <code>getName()</code>, <code>getPrice()</code>, and <code>getWeight()</code>. This is what you already have. Then you need a different interface for a general search machine<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn2">2</a>, which must provide information like:</p>
<ul>
<li>what is the actual class of the object</li>
<li>what attributes does that class have</li>
<li>what are the actual values of these attributes for the object.</li>
</ul>
<p>This is a classic reflection interface that gives you information about the properties of classes and objects.<br>But you also need a third interface for product maintenance that allows you to define new product classes, specify the attributes for them, create instances of these classes, and set the attribute values of these instances. Such an interface is called a “Meta-Object Protocol (MOP)” and thoroughly discussed in [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk1">1</a>]. The reflection protocol is a subset of such a MOP.<br><img src="/2023/03/29/reflection/fig3.jpg" alt="Fig. 3: A Better Model"><br>Fig. 3: A Better Model</p>
<h2 id="Meta-Classes-for-C"><a href="#Meta-Classes-for-C" class="headerlink" title="Meta Classes for C++"></a>Meta Classes for C++</h2><p>What is the meaning of “Meta-Object Protocol”? Well, meta information is information about something else seen from a level beyond – a meta level. So, information about the attribute values of an object, say <code>someBook.author</code>, is information on the object level. But information about the properties of the object itself, about its attributes, its structure, etc. is meta information.<br>In C++, this information is captured in the class definition for the object, so the class is a meta-object. And in C++, you have all the functionality of a MOP at class level – which is at development time. But that level is not available at runtime: You cannot manipulate classes like objects, you cannot add new classes at runtime. The idea of a MOP is to collapse the meta-level (classes) and the object level (objects); i.e. make the class definitions normal objects and the object properties are normal attribute values of the class definitions that can be manipulated at runtime.<br>While languages like CLOS or Smalltalk provide this combined level directly, C++ as strongly typed compiler language has no such features. So, what can you do about it? The typical solution is to provide a MOP yourself, as proposed e.g. in [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk2">2</a>] or [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk3">3</a>].</p>
<h3 id="MOP-Overview"><a href="#MOP-Overview" class="headerlink" title="MOP Overview"></a>MOP Overview</h3><p>For simplicity, we ignore methods for now, so our MOP must provide:</p>
<ul>
<li>definition of new classes</li>
<li>adding attributes to classes</li>
<li>querying attributes of classes</li>
<li>creating objects</li>
<li>querying the class of an object</li>
<li>setting attribute values of an object</li>
<li>querying attribute values of an object</li>
<li>deleting objects</li>
</ul>
<p>If you use an old rule of OO design, you take all the nouns of the above requirements and make classes out of them. When you think about the “attributes” and “values” you have to decide whether they are typed. As the underlying language C++ is typed this should be mirrored in your design.<br>Another question is about inheritance support. For our example with the Internet shop and a product hierarchy this would probably quite useful. So, a first class model is shown in Fig 4.<br><img src="/2023/03/29/reflection/fig4.jpg" alt="Fig. 4: MOP Class Model"><br>Fig. 4: MOP Class Model</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>While it is useful to go top-down for a general overview, it’s easier to start with the simple basic things for the details. So we’ll first look at <code>Type</code>.<br>The main purpose of <code>Type</code> is to distinguish different kind of <code>Attribute</code>s. For this, a simple <code>enum</code> would suffice. But the idea of types is to have different kind of <code>Values</code> for different <code>Type</code>s, so the <code>Type</code> should create new <code>Value</code>s. So we put the <code>enum</code> inside the <code>Type</code> class, provide the <code>newValue()</code> method, and get the interface shown in Fig. 4.<br>Now for implementation. Though we don’t look closer at <code>Value</code> for now, if we have different kind of values we probably need some base class for them. Let’s call it “<code>BaseValue</code>“, and <code>newValue()</code> can just return a pointer to <code>BaseValue</code>.<br>Now we know what to create, but how? While there are several patterns to implement polymorphic creation [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk4">4</a>], the simplest one for our purpose is probably the Prototype, which can be easily implemented with a simple <code>static vector</code><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn3">3</a>.<br>Now we have everything to implement the entire class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TypeT</span> &#123;stringT, intT, doubleT, unknownT&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Type</span><span class="params">(TypeT typeId_)</span> : typeId(typeId_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseValue * <span class="title">newValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prototypes[typeId]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TypeT <span class="title">getType</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        prototypes[stringT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;string&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        prototypes[intT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">        prototypes[doubleT] = <span class="keyword">new</span> <span class="built_in">Value</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TypeT typeId;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> vector&lt;BaseValue *&gt; prototypes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;BaseValue *&gt; <span class="title">Type::prototypes</span><span class="params">(Type::unknownT)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h3><p>As we have decided to create new <code>Value</code>s through <code>Type</code>, <code>Attribute</code> contains only a name and type, so here is its implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Attribute</span>(<span class="type">const</span> string &amp; name_, Type::TypeT typeId)</span><br><span class="line">     : <span class="built_in">name</span>(name_), <span class="built_in">type_</span>(typeId)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> string &amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Type type_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>We can now finish the class (meta-) level of our model by looking at <code>Class</code> itself. As multiple inheritance is probably not an issue for our purposes, we have just one pointer to a base class (which can be 0). The more important question is the attribute list: Should it hold only the attributes defined for this class or should it include all inherited attributes? While for the actual object value access a complete list is more useful (and much faster), for class maintenance it might be important to know which attribute was defined in which class. So we just keep both. For the complete list, the order might be significant: should the own attributes come first or the inherited ones? In most illustrations the inherited attributes come first, so we keep this order as well.<br>What happens if the name of an attribute is the same as the name of an inherited attribute? As C++ allows it, we can allow it as well (saving us some extra effort to check this), but in this case we must guarantee that on lookup of an attribute by name we get the most derived attribute. So, <code>findAttribute()</code> must do a reverse search. What shall we return from <code>findAttribute()</code>? The STL way would be to return an iterator, but for applications with GUIs (to create new objects and assign values to its attributes based on selection lists) an index-based access to the attributes will be more appropriate. So <code>findAttribute()</code> returns an index and <code>getAttribute()</code> takes an index and returns an <code>Attribute</code>. So the <code>Attribute</code> lists need to be an indexed containers, so we choose <code>vector</code>s for them.<br>A major purpose of <code>Class</code> is to create <code>Object</code>s from it, so it has a method <code>newObject()</code> which returns a pointer to an <code>Object</code>. Do we need to keep a repository with references to all created objects? For a full reflection interface we should do this. But for actual applications this is nearly never useful, as objects of the same class are created for completely different purposes. But do we need the repository for internal use? It depends on what we want to do with objects after they were created. This leads directly to another important decision: What do we do with already existing objects if we add a new attribute to a class? One option is to add this attribute to all existing objects and assign it a default value. The other option is to leave these existing objects and add the new attribute only to new objects. This leads to differently structured objects of the same class at the same time, and then we must add some version information to the objects. But there is a third option: To forbid the modification of a class definition once an instance of that class was created. This is the easiest option, so we adopt it for our MOP and add a flag <code>definitionFix</code>. With that flag, we can skip the object repository.<br>A last design question is when to add the attributes: At creation time of a class definition (through the constructor) or later (with a member function)? For different applications both options might be useful, so we’ll provide two constructors and <code>addAttribute()</code>.<br>Now you can implement this<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn4">4</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDef</span></span><br><span class="line">&#123;        <span class="comment">//typedefs Container, Iterator for attributes</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> * base, <span class="type">const</span> string &amp; name_)</span><br><span class="line">     : <span class="built_in">baseClass</span>(base), <span class="built_in">name</span>(name_),</span><br><span class="line">       <span class="built_in">definitionFix</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">baseInit</span>();</span><br><span class="line">        effectiveAttributes.<span class="built_in">insert</span>(effectiveAttributes.<span class="built_in">end</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">begin</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> iterator&gt;</span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> * base, <span class="type">const</span> string &amp; name_,</span><br><span class="line">             iterator attribBegin, iterator attribEnd)</span><br><span class="line">     : <span class="built_in">baseClass</span>(base), <span class="built_in">name</span>(name_),</span><br><span class="line">       <span class="built_in">ownAttributes</span>(attribBegin, attribEnd),</span><br><span class="line">       <span class="built_in">definitionFix</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">baseInit</span>();</span><br><span class="line">        effectiveAttributes.<span class="built_in">insert</span>(effectiveAttributes.<span class="built_in">end</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">begin</span>(),</span><br><span class="line">                                   ownAttributes.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Object * <span class="title">newObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        definitionFix = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AttrIterator <span class="title">attribBegin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">AttrIterator <span class="title">attribEnd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Attribute <span class="type">const</span> &amp; <span class="title">getAttribute</span><span class="params">(<span class="type">size_t</span> idx)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAttribute</span><span class="params">(<span class="type">const</span> Attribute &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getAttributeCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">findAttribute</span><span class="params">(string <span class="type">const</span> &amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this does a reverse search to find the most derived</span></span><br><span class="line">        AttributeContainer::const_reverse_iterator i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = effectiveAttributes.<span class="built_in">rbegin</span>();</span><br><span class="line">             i != effectiveAttributes.<span class="built_in">rend</span>();</span><br><span class="line">             ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;<span class="built_in">getName</span>() == name)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">distance</span>(i, effectiveAttributes.<span class="built_in">rend</span>()) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getAttributeCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (baseClass)</span><br><span class="line">        &#123;</span><br><span class="line">            baseClass-&gt;definitionFix = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">copy</span>(baseClass-&gt;<span class="built_in">attribBegin</span>(), baseClass-&gt;<span class="built_in">attribEnd</span>(),</span><br><span class="line">                 <span class="built_in">back_inserter</span>&lt;AttributeContainer&gt;(effectiveAttributes));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassDef <span class="type">const</span> * <span class="type">const</span> baseClass;</span><br><span class="line">    string name;</span><br><span class="line">    AttributeContainer ownAttributes, effectiveAttributes;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> definitionFix;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h3><p><img src="/2023/03/29/reflection/fig5.jpg" alt="Fig. 5: Value Model"><br>Fig. 5: Value Model<br>Before we can design <code>Object</code>, we have to think about <code>Value</code>. We need a common interface to manage them, which we already called <code>BaseValue</code>. But what interface do we need? The whole idea of <code>Value</code> is to store values, so we need a <code>set()</code> function. What parameter? The only thing we have is <code>BaseValue</code>, so that’s the parameter type. Pass by value, by reference, or by pointer? Definitely not by value, as <code>BaseValue</code> is only an interface. On the other hand, what you pass is a value, so the parameter passing should be by value to let you pass temporaries. So one option would be to pass by const reference. But though this helps for the problem at hand, it doesn’t cure the fundamental problem: you should have a value, but all you have is a polymorphic interface. The real solution here is the pimpl idiom, also known as Cheshire Cat, Envelope/Letter, or more generally Handle/Body. So we add a handle class, name it <code>Value</code>, and look at it later again. For now we’re still at <code>BaseValue</code>.<br>We now have <code>set(Value)</code>, so what about <code>get()</code>? The return type of <code>get()</code> would be <code>Value</code>, and the implementation would look like:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value BaseValue::<span class="keyword">get</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// calls Value(BaseValue const &amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>But that we can do directly, so <code>get()</code> doesn’t make much sense.<br>What other <code>BaseValue</code> functions do we need? Values must be copied, so we add <code>clone()</code>.<br>That’s all what we really need from a value, but we add <code>asString()</code> for convenience<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn5">5</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseValue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseValue</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaseValue * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fromString()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set</span><span class="params">(Value <span class="type">const</span> &amp; v)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// no get()!</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Type info</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RealValue"><a href="#RealValue" class="headerlink" title="RealValue"></a>RealValue</h3><p>Now, as we have the interface, what about the implementation? We need values for <code>int</code>, <code>double</code>, <code>string</code>, …. And an <code>int</code> value must hold an <code>int</code>, a <code>double</code> value a <code>double</code>, etc. This looks like an opportunity for a template. So, let’s define <code>RealValue</code>, derive it from <code>BaseValue</code>, implement the inherited interface, and we’re nearly done. But as <code>RealValue</code> is just a wrapper around <code>T</code> with some additional functionality, but essentially still a <code>T</code>, we should provide conversion in both directions, by providing a converting constructor and a conversion operator.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PlainT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealValue</span> : <span class="keyword">public</span> BaseValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealValue</span>(PlainT v)</span><br><span class="line">     : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealValue * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RealValue</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ostringstream os;</span><br><span class="line">        os &lt;&lt; val;</span><br><span class="line">        <span class="keyword">return</span> os.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">PlainT</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// conversion to plain type</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealValue&lt;PlainT&gt;::<span class="built_in">set</span>(Value <span class="type">const</span> &amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        val = v.<span class="built_in">get</span>&lt;PlainT&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PlainT val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A note about <code>RealValue</code>: As we have conversion in both directions, we can use <code>RealValue</code> like <code>T</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RealValue&lt;<span class="type">int</span>&gt; i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line">RealValue&lt;<span class="type">double</span>&gt; d = i + <span class="number">5.2</span> / (i*<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Nearly: the following doesn’t work:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RealValue&lt;string&gt; name, author = <span class="string">&quot;Bjarne&quot;</span>, title = <span class="string">&quot;The C++ PL&quot;</span>;</span><br><span class="line">name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The reason is that the compiler only applies one user-defined conversion, but for string literals, you need two: from <code>char const *</code> to <code>string</code>, and from <code>string</code> to <code>RealValue</code>. If you want to work with <code>RealValue</code> outside the MOP, you should define a specialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealValue</span>&lt;string&gt; : <span class="keyword">public</span> BaseValue, <span class="keyword">public</span> string</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealValue</span>(string <span class="type">const</span> &amp; s) : <span class="built_in">string</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">RealValue</span>(<span class="type">char</span> <span class="type">const</span> * s) : <span class="built_in">string</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">RealValue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealValue * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RealValue</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;string&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no operator string(), conversion to base automatically</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Value <span class="type">const</span> &amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string::<span class="keyword">operator</span>=(v.<span class="built_in">get</span>&lt;string&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Note: Actually, its not really clean to derive <code>RealValue</code> from <code>std::string</code>, but as long as you don’t delete a <code>RealValue</code> through a pointer to <code>string</code>, it will work.</p>
<h3 id="Value-handle"><a href="#Value-handle" class="headerlink" title="Value handle"></a>Value handle</h3><p>Now back to the handle class <code>Value</code>. As a handle class, it contains its body and cares for it. Its main job is to adopt/create and to delete its body. And it mirrors the interface of the body and forwards all messages. But it should also be a real value class, thus providing default and copy constructor and assignment. But how to implement the default constructor? As we don’t know what type to create, we must create an empty handle without a body and check before forwarding if we actually have something to forward to. The assignment is essentially the <code>set()</code>, so we skip the <code>set()</code>.<br>Now let’s come back to the <code>get()</code>. Of course, to return a <code>Value</code> or <code>BaseValue</code> doesn’t make sense. But what about returning the <code>RealValue</code> or even the wrapped underlying value? That would be really useful, but for that we have to tell <code>get()</code> what we want as return type. So <code>get()</code> becomes a member template and so can return whatever is inside the <code>RealValue&lt;&gt;</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>        <span class="comment">// Value handle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Value</span>(BaseValue <span class="type">const</span> &amp; bv)</span><br><span class="line">     : <span class="built_in">v</span>(bv.<span class="built_in">clone</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Value</span>(Value <span class="type">const</span> &amp; rhs)</span><br><span class="line">     : <span class="built_in">v</span>(rhs.v ? rhs.v-&gt;<span class="built_in">clone</span>() : <span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Value</span><span class="params">(BaseValue * bv = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">     : v(bv)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Value</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Value &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Value &amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this is not a typical pimpl assignment, but a set()</span></span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rhs.v)</span><br><span class="line">            &#123; <span class="comment">// fine, all v&#x27;s exist</span></span><br><span class="line">                v-&gt;<span class="built_in">set</span>(rhs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; <span class="comment">// the other v doesn&#x27;t exist, so we must delete our own :-(</span></span><br><span class="line">                BaseValue * old = v;</span><br><span class="line">                v = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">delete</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// we don&#x27;t have a v, so just copy the other</span></span><br><span class="line">            v = (rhs.v ? rhs.v-&gt;<span class="built_in">clone</span>() : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PlainT&gt;</span><br><span class="line">    <span class="function">PlainT <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            RealValue&lt;PlainT&gt; <span class="type">const</span> &amp; rv</span><br><span class="line">                = <span class="keyword">dynamic_cast</span>&lt;RealValue&lt;PlainT&gt; <span class="type">const</span> &amp;&gt;(*v);</span><br><span class="line">            <span class="keyword">return</span> rv;        <span class="comment">// uses conversion operator</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">PlainT</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">asString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> v-&gt;<span class="built_in">asString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BaseValue * v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Finally we come to <code>Object</code>. Now, as we have everything else, an <code>Object</code> is mainly a container for its attribute values. To ease implementation, we will structurally mirror the attribute container in the class definition, so we use a <code>vector</code>. As we have so much effort invested in our <code>Value</code> handle, it would make sense to store that in the <code>vector</code>. But for future extensions it will be easier to have the <code>BaseValue</code> pointers directly available.<br>The constructor will create the values through the types of the attributes, so the only constructor takes a <code>ClassDef*</code>.<br>To set and get the values for the attributes, we provide two options: to specify the attribute by name and also by index.<br>For reflection purposes (as well as for internal implementation) we need a pointer to the class definition, but then we have it all:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Object</span><span class="params">(ClassDef <span class="type">const</span> * class_)</span></span></span><br><span class="line"><span class="function">     : myClass(class_), values(class_-&gt;getAttributeCount())</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">buildValueList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ClassDef <span class="type">const</span> &amp; <span class="title">instanceOf</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">getValue</span><span class="params">(<span class="type">size_t</span> attribIdx)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *values[attribIdx]; <span class="comment">// calls Value(BaseValue &amp;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Value <span class="title">getValue</span><span class="params">(string <span class="type">const</span> &amp; attribName)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> idx = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">findAttribute</span>(attribName);</span><br><span class="line">        <span class="comment">// should check for not found</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getValue</span>(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">size_t</span> idx, Value <span class="type">const</span> &amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        values[idx]-&gt;<span class="built_in">set</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(string <span class="type">const</span> &amp; attribName, Value <span class="type">const</span> &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> idx = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">findAttribute</span>(attribName);</span><br><span class="line">        <span class="comment">// should check for not found</span></span><br><span class="line">        <span class="built_in">setValue</span>(idx, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> vector&lt;BaseValue *&gt; ValueContainer;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildValueList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ClassDef::AttrIterator a;</span><br><span class="line">        ValueContainer::iterator i = values.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (a = <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribBegin</span>();</span><br><span class="line">             a != <span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribEnd</span>();</span><br><span class="line">             ++a, ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            *i = a-&gt;<span class="built_in">getType</span>().<span class="built_in">newValue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassDef <span class="type">const</span> * <span class="type">const</span> myClass;</span><br><span class="line">    ValueContainer values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now the MOP is complete. Let’s use it:<br>Creating the <code>Product</code> class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassDef * product</span><br><span class="line">     = <span class="keyword">new</span> <span class="built_in">ClassDef</span>(<span class="number">0</span>, <span class="comment">// no base class for Product</span></span><br><span class="line">                    <span class="string">&quot;Product&quot;</span>); <span class="comment">// name of class</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Adding attributes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Product Number&quot;</span>, Type::intT));</span><br><span class="line">product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Name&quot;</span>, Type::stringT));</span><br><span class="line">product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>, Type::doubleT));</span><br><span class="line">product-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Weight&quot;</span>, Type::doubleT));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Creating the <code>Book</code> class with an attribute list:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Attribute&gt; attrL;</span><br><span class="line">attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Author&quot;</span>, Type::stringT));</span><br><span class="line">attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Title&quot;</span>, Type::stringT));</span><br><span class="line">attrL.<span class="built_in">push_back</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;ISBN&quot;</span>, Type::intT));</span><br><span class="line"></span><br><span class="line">ClassDef * book</span><br><span class="line"> = <span class="keyword">new</span> <span class="built_in">ClassDef</span>(product, <span class="comment">// base class</span></span><br><span class="line">                <span class="string">&quot;Book&quot;</span>,</span><br><span class="line">                attrL.<span class="built_in">begin</span>(), attrL.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Creating an object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object * <span class="title">bscpp</span><span class="params">(book-&gt;newObject())</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Setting-the-values-for-the-objects"><a href="#Setting-the-values-for-the-objects" class="headerlink" title="Setting the values for the objects:"></a>Setting the values for the objects:</h4><p>Set an int value by index (don’t forget that index 0 is <code>ProductNo</code>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bscpp-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>, <span class="built_in">RealValue</span>&lt;<span class="type">int</span>&gt;(<span class="number">12345</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Same for a string value:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bscpp-&gt;<span class="built_in">setValue</span>(<span class="number">4</span>, <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;Bjarne Stroustrup&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Better way: set value by name this gives the most derived attribute:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bscpp-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Title&quot;</span>,</span><br><span class="line">                <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;The C++ Programming Language&quot;</span>));</span><br><span class="line">bscpp-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Weight&quot;</span>, <span class="built_in">Value</span>&lt;<span class="type">double</span>&gt;(<span class="number">370</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Getting-the-values"><a href="#Getting-the-values" class="headerlink" title="Getting the values:"></a>Getting the values:</h4><p>Display a book:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassDef::AttrIterator a;</span><br><span class="line"><span class="type">size_t</span> idx;</span><br><span class="line"><span class="keyword">for</span> (a = book-&gt;<span class="built_in">attribBegin</span>(), idx = <span class="number">0</span>;</span><br><span class="line">     a != book-&gt;<span class="built_in">attribEnd</span>();</span><br><span class="line">     ++a, ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">         &lt;&lt; bscpp-&gt;<span class="built_in">getValue</span>(idx).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>and we get:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Product Number: <span class="number">12345</span></span><br><span class="line">Name:</span><br><span class="line">Price:</span><br><span class="line">Weight: <span class="number">370</span></span><br><span class="line">Author: Bjarne Stroustrup</span><br><span class="line">Title: The C++ Programming Language</span><br><span class="line">ISBN:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>So, our MOP is complete. For our sample application, you have to add a class repository, some nice GUI to define classes and objects, creating the index for the search machine, provide an interface for <code>ShoppingCart</code>, but then you’re done, and Susan is happy as she now can create her own new product categories at runtime.</p>
<h2 id="Reflection-for-existing-C-classes"><a href="#Reflection-for-existing-C-classes" class="headerlink" title="Reflection for existing C++ classes"></a>Reflection for existing C++ classes</h2><p>If you provide the interface for the <code>ShoppingCart</code> in our example, you’ll find that it isn’t so easy. If all classes are dynamic classes, all access must go through the MOP:<br>A <code>getName()</code> for <code>Book</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">bookGetName</span><span class="params">(Object <span class="type">const</span> * book)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (book-&gt;<span class="built_in">instanceOf</span>().<span class="built_in">getName</span>() != <span class="string">&quot;Book&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* throw some exception */</span></span><br><span class="line">    &#125;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//  name = book-&gt;author + &quot;: &quot; + book-&gt;title;  it was so easy...</span></span><br><span class="line"></span><br><span class="line">    string author = book-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Author&quot;</span>).<span class="built_in">get</span>&lt;string&gt;();</span><br><span class="line">    string title = book-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Title&quot;</span>).<span class="built_in">get</span>&lt;string&gt;();</span><br><span class="line">    name = author + <span class="string">&quot;: &quot;</span> + title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>For a lot of applications, it would be useful to provide some classes of a hierarchy as C++ classes, e.g. <code>Product</code>, but still let the user add classes of the same hierarchy at runtime, e.g. <code>TShirt</code>. So, let’s look at this. If we want access through our MOP to C++ classes, we need a <code>getValue()</code> to which we can give the attribute we want to access at runtime. So, here it is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value <span class="title">getValue</span><span class="params">(Object *o, MemberPointer mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o-&gt;*mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The magic lies in <code>&#39;-&gt;*&#39;</code>: This is the pointer-to-member selector of C++.</p>
<h3 id="Pointer-to-member"><a href="#Pointer-to-member" class="headerlink" title="Pointer to member"></a>Pointer to member</h3><p>You can imaging a pointer-to-member in C++ as an offset<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn6">6</a> from the base address of an object to a specific member. If you apply that offset to such a base address, you get a reference to the member (Fig. 6). But as a pointer-to-member is a normal data type in C++, you can store them in containers, pass them to functions, etc. Thus, you can write the function above, building the fundamental base for our combination of C++-classes and runtime-classes.<br><img src="/2023/03/29/reflection/fig6.jpg" alt="Fig. 6: Pointer to Member"><br>Fig. 6: Pointer to Member<br>Let’s look at some details of pointer-to-members. As an example, we use the following class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    RealValue&lt;<span class="type">double</span>&gt; price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealValue&lt;string&gt; author, title;</span><br><span class="line">    RealValue&lt;<span class="type">double</span>&gt; weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Book b, *bp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A pointer-to-member is a type that is derived from two other types: The type of the base object (<code>Book</code> in our example) and the type of the member (<code>RealValue&lt;&gt;</code>). The type decorator for a pointer-to-member is ‘<code>::*</code>‘, so let’s define two variables with initialization:<br><code>RealValue Book::* bookStringMemPtr = &amp;Book::author;</code><br><code>RealValue Book::* bookDoubleMemPtr = &amp;Book::weight;</code> The pointer-to-member selector comes in two variations: as ‘<code>.*</code>‘ you can apply it to references of the class and as ‘<code>-&gt;*</code>‘ it takes a pointer. It is a binary operand, as left operand it takes a reference (or pointer) to an object and as right operand a pointer-to-member. So, with the above definitions, you can do things like</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b.*bookStringMemPtr = <span class="string">&quot;Bjarne Stroustrup&quot;</span>; <span class="comment">// assigns b.author</span></span><br><span class="line"></span><br><span class="line">bookStringMemPtr = &amp;Book::title;</span><br><span class="line"></span><br><span class="line">bp-&gt;*bookStringMemPtr = <span class="string">&quot;The C++ Programming Language&quot;</span>; <span class="comment">// assigns b.author</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Of course, as <code>title</code> is a private member of <code>Book</code>, the assignment of the pointer-to-member must be at the scope of that class. But the pointer-to-members themselves can be used even if you don’t have access privileges to the members (as long as you have access to the pointer-to-member).</p>
<h3 id="pointer-to-member-Types"><a href="#pointer-to-member-Types" class="headerlink" title="pointer-to-member Types"></a>pointer-to-member Types</h3><p>A word about the types: <code>RealValue Book::*</code>, <code>RealValue Product::*</code>, and <code>BaseValue Product::*</code> are different types. But are there conversions? The C++ standard provides a conversion from a pointer-to-member of a base class to a pointer-to-member of a derived class. That makes sense: You can apply an offset to a member of a base class to the base address of a derived object as well, as the base is a part of the derived object<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fn7">7</a>. So you can assign<br><code>bookDoubleMemPtr = &amp;Product::price;</code> as the <code>price</code> is part of each <code>Book</code> instance.<br>The other way around it obviously doesn’t work, you couldn’t initialize<br><code>RealValue Product::* &amp;Book::author;</code> as <code>author</code> is not a member of each instance of type <code>Product</code>.<br>But the standard does not provide a conversion from <code>RealValue Book::*</code> to <code>BaseValue Book::*</code>, though it would be save: If the result type of the pointer-to-member selector is a reference to a derived class, it can be safely converted to a reference of a respective base class, so it would also be safe to let the compiler do the conversion automatically and therefore also convert the pointer-to-members themselves. As already mentioned, the standard doesn’t provide (implicit) and even doesn’t allow (explicit through <code>static_cast</code>) that conversion, probably because the committee didn’t see any use for pointer-to-data-members at all (see [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk5">5</a>]), and for pointer-to-member-functions that conversion really doesn’t make sense.<br>The problem for us is: we need that conversion. We want to keep pointer-to-members to all members of a class in one common container, but what could be the type of that container’s elements? One option would be to force the conversion through a <code>reinterpret_cast</code>, but the only thing you can safely do with a <code>reinterpret_cast</code>ed thing is to <code>reinterpret_cast</code> it back, and for that you have to store the original type as well. So we use another option: we just define the conversion! But as C++ doesn’t allow you to define your own conversions to compiler-provided types (and in this sense the pointer-to-members are compiler defined, though the involved single types like <code>Book</code> or <code>BaseValue</code> are user-defined), we have to define wrapper classes around them.<br>Here’s the implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemPtrBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">MemPtrBase</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MemPtrBase</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MemPtrBase</span>(MemPtrBase <span class="type">const</span> &amp;);</span><br><span class="line">    MemPtrBase &amp; <span class="keyword">operator</span>=(MemPtrBase <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType, <span class="keyword">typename</span> TargetType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedMemPtr</span> : <span class="keyword">public</span> MemPtrBase&lt;BaseType, BaseTargetType&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypedMemPtr</span>(TargetType BaseType::* ptr)</span><br><span class="line">     : <span class="built_in">p</span>(ptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.*p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.*p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TargetType BaseType::* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemPtr</span> <span class="comment">// this is a handle only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType2, <span class="keyword">typename</span> TargetType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MemPtr</span><span class="params">(TargetType BaseType2::* ptr)</span></span></span><br><span class="line"><span class="function">     : p(new TypedMemPtr&lt;BaseType, BaseTargetType,</span></span><br><span class="line"><span class="function">        TargetType&gt;(static_cast&lt;TargetType BaseType::*&gt;(ptr)))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MemPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseTargetType &amp; <span class="title">value</span><span class="params">(BaseType &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">value</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BaseTargetType <span class="type">const</span> &amp; <span class="title">value</span><span class="params">(BaseType <span class="type">const</span> &amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;<span class="built_in">value</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MemPtrBase&lt;BaseType, BaseTargetType&gt; * p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Some notes to the code: <code>BaseType</code> is used for the class to which a pointer to member is applied (e.g. <code>Book</code>), <code>TargetType</code> is the result type to which a pointer-to-member points (<code>RealValue</code>), and <code>BaseTargetType</code> is the base class of <code>TargetType</code> (<code>BaseValue</code>). <code>MemPtrBase&lt;&gt;</code> is the common base class as we need it (e.g. <code>MemPtrBase</code>, which stands for <code>BaseValue Book::*</code>), <code>TypedMemPtr&lt;&gt;</code> hold an actual C++ pointer-to-member (<code>TypedMemPtr &gt;</code>), and <code>MemPtr&lt;&gt;</code> is a handle class around <code>MemPtrBase&lt;&gt;</code> to store them in a container. Here, the actual access function is the <code>value()</code> member function. If you want, you can add a global operator ‘<code>-&gt;*</code>‘ (as template function), but you can’t provide the operator by a member function (as the left operand is not the class instance), and you can’t overload ‘<code>.*</code>‘ (this is one of the few non-overloadable operators).<br>The <code>MemPtr</code> constructor is a member template with two template parameters: a <code>BaseType2</code> and the <code>TargetType</code>. The second one is clear as it defines the actual <code>TypedMemPtr</code> to be constructed, but the <code>BaseType2</code> is not so obvious. If we omit the <code>BaseType2</code>, so only having</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> BaseTargetType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemPtr</span> <span class="comment">// this is a handle only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MemPtr</span><span class="params">(TargetType BaseType::* ptr)</span></span></span><br><span class="line"><span class="function">     : p(new TypedMemPtr&lt;BaseType, BaseTargetType, TargetType&gt;(ptr))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and then we try to create a</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemPtr&lt;Book, BaseValue&gt; <span class="title">mp2</span><span class="params">(&amp;Product::price)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>some compilers give an error, as they cannot fiddle out the correct conversion. This would be to convert <code>RealValue Product::*</code> to <code>RealValue Book::*</code>, which should be done automatically, and then to instantiate <code>MemPtr</code>‘s constructor with <code>RealValue</code> as <code>TargetType</code>.<br>One way to solve this is to explicitly cast the pointer-to-member:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemPtr&lt;Book, BaseValue&gt;</span></span><br><span class="line"><span class="function">    <span class="title">mp2</span><span class="params">(<span class="keyword">static_cast</span>&lt;RealValue&lt;<span class="type">double</span>&gt; Book::*&gt;(&amp;Product::price))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>but that’s quite a lot to type. It’s actually much easier to move that explicit conversion into the constructor itself and just provide an additional template parameter, as shown in the implementation above. The compiler checks the conversion anyway, so you will get a compile time error if that conversion is not allowed (e.g. if you try to convert a <code>RealValue Book::*</code> to <code>RealValue Cd::*</code>.</p>
<h3 id="C-classes"><a href="#C-classes" class="headerlink" title="C++ classes"></a>C++ classes</h3><p>The <code>MemPtr</code>s allow you to access the attribute values of an ordinary C++ object. This helps for one part of the MOP. But what about the attributes themselves? The compiler has the necessary knowledge, but unfortunately there is no standard way to access that knowledge at runtime. So we must provide it and define an interface for it. To allow a smooth integration with our existing <code>ClassDef</code>, we provide an <code>Attribute</code> iterator as interface. For now, we provide the information about the attributes manually, but in a following article we’ll explore the use of a pre-processor for that.<br>So, for our class <code>Book</code> we provide the following functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> MemPtr&lt;Book, FinalValue&gt; MemberPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ownAttribCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Attribute * <span class="title">ownAttribBegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Attribute a[]</span><br><span class="line">            = &#123;<span class="built_in">Attribute</span>(<span class="string">&quot;Author&quot;</span>, Type::stringT),</span><br><span class="line">               <span class="built_in">Attribute</span>(<span class="string">&quot;Title&quot;</span>, Type::stringT),</span><br><span class="line">               <span class="built_in">Attribute</span>(<span class="string">&quot;Publisher&quot;</span>, Type::stringT),</span><br><span class="line">               <span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>, Type::doubleT),</span><br><span class="line">               <span class="built_in">Attribute</span>(<span class="string">&quot;Weight&quot;</span>, Type::doubleT)</span><br><span class="line">              &#125;;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Attribute * <span class="title">ownAttribEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ownAttribBegin</span>() + <span class="built_in">ownAttribCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> MemberPtr * <span class="title">memberBegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> MemberPtr m[]</span><br><span class="line">            = &#123;<span class="built_in">MemberPtr</span>(&amp;Book::productNo),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Product::weight),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Book::author),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Book::title),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Book::publisher),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Book::price),</span><br><span class="line">               <span class="built_in">MemberPtr</span>(&amp;Book::weight)</span><br><span class="line">              &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> MemberPtr * <span class="title">memberEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memberBegin</span>() + <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealValue&lt;string&gt; author, title, publisher;</span><br><span class="line">    RealValue&lt;<span class="type">double</span>&gt; price, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Please note the difference between <code>ownAttribBegin()</code> and <code>memberBegin()</code>: the first provides information only about the own attributes, while the latter provides access also to base class members. This separation makes sense: while on object level all data members build together one object, on the class level the base class is a different entity and should be available as common base class for the meta object protocol as well. But this separation has consequences: we can’t derive a C++ class from a MOP class (but this is definitely no real restriction) and the C++ base class must be also made known to the MOP (but that’s useful anyway).<br>We have no function that provides information about the base classes, as the <code>baseClass</code> in <code>ClassDef</code> must be made a <code>ClassDef</code> instance as well, as noted above. The C++ base classes are not of much use for our application.<br>With these functions, we can build a <code>ClassDef</code> from a C++ class; it’s so easy that we can even provide a helper function for that:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CppClass&gt;</span><br><span class="line"><span class="function">ClassDef <span class="title">makeClass</span><span class="params">(ClassDef <span class="type">const</span> * base, string <span class="type">const</span> &amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ClassDef</span>(base, name,</span><br><span class="line">                    CppClass::<span class="built_in">ownAttribBegin</span>(), CppClass::<span class="built_in">ownAttribEnd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now, we can build our <code>ClassDef</code>s for <code>Product</code> and <code>Book</code> and create instances from them:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassDef <span class="title">base</span><span class="params">(makeClass&lt;DynaProduct&gt;(<span class="number">0</span>, <span class="string">&quot;Product&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">ClassDef <span class="title">book</span><span class="params">(makeClass&lt;Book&gt;(base, <span class="string">&quot;Book&quot;</span>))</span></span>;</span><br><span class="line">book.<span class="built_in">newObject</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>But stop – though this works, it’s not what we want: now, the instances are not genuine C++ objects, but MOP objects, and all access must still go through the MOP.</p>
<h3 id="C-objects"><a href="#C-objects" class="headerlink" title="C++ objects"></a>C++ objects</h3><p>What we want are real C++ objects that we can also access through the MOP, i.e. through the <code>Object</code> interface. The OO way to do that is to derive our <code>Product</code> from <code>Object</code>, but though other OO languages like Smalltalk do that, I think there’s a better, less intrusive option: we provide an adaptor.<br>From [<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bk4">4</a>] we learn that there are two options for the adaptor pattern: to design the adaptor class as forwarding wrapper class derived only from <code>Object</code> and containing a <code>Product</code> member or using multiple inheritance and derive the adaptor from <code>Object</code> and <code>Product</code>. For simplicity, we will use the first option, but real world applications often benefit from the second approach. So we provide a wrapper class <code>CppObject</code> that is derived from <code>Object</code> and that holds the original C++ object. It implements the interface of <code>Object</code> (<code>getValue()</code> and <code>setValue()</code>) through our <code>MemPtr</code>s:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OrigClass&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CppObject</span> : <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> MemPtr&lt;OrigClass, BaseValue&gt; MemberPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CppObject</span>(ClassDef <span class="type">const</span> * myClass)</span><br><span class="line">     : <span class="built_in">Object</span>(myClass), <span class="built_in">myObject</span>(), <span class="built_in">members</span>(OrigClass::<span class="built_in">memberBegin</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Object * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CppObject</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Object::getValue; <span class="comment">// importing getValue(name)</span></span><br><span class="line">    <span class="keyword">using</span> Object::setValue; <span class="comment">// importing setValue(name)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Value <span class="title">getValue</span><span class="params">(<span class="type">size_t</span> idx)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> members[idx].<span class="built_in">value</span>(myObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">size_t</span> idx, Value <span class="type">const</span> &amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BaseValue * p = &amp;(members[idx].<span class="built_in">value</span>(myObject));</span><br><span class="line">        p-&gt;<span class="built_in">set</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MemberPtr * members;</span><br><span class="line">    OrigClass myObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A useful rule of OO design says that only leaf classes should be concrete, so let’s define <code>Object</code> as abstract base class and create a new class <code>DynaObject</code> that resembles our former <code>Object</code> for real MOP class instances (Fig. 7).<br><img src="/2023/03/29/reflection/fig7.jpg" alt="Fig. 7: Object Hierarchy"><br>Fig. 7: Object Hierarchy<br>If we now do a <code>prod.newObject()</code>, we still get it wrong: we now get a <code>DynaObject</code>, but we want a <code>CppObject</code>. To solve that, we must provide the <code>ClassDef</code> with a means to create the correct kind of object, and the simplest way to do that is a factory method: we provide a static creation function in <code>CppObject&lt;&gt;</code> and <code>DynaObject</code>, give a pointer to that function to the <code>ClassDef</code>‘s constructor, store it and use that function in <code>ClassDef::newObject()</code>:<br>Creation functions for <code>DynaObject</code> and <code>CppObject</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object *</span></span><br><span class="line"><span class="function"><span class="title">DynaObject::newObject</span><span class="params">(ClassDef <span class="type">const</span> * myClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DynaObject</span>(myClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OrigClass&gt;</span><br><span class="line">Object *</span><br><span class="line">CppObject&lt;OrigClass&gt;::<span class="built_in">newObject</span>(ClassDef <span class="type">const</span> * myClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CppObject</span>(myClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Changes to <code>ClassDef</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDef</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Object * (*CreateObjFunc)(ClassDef <span class="type">const</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> *, string <span class="type">const</span> &amp;,</span><br><span class="line">             CreateObjFunc objFunc,</span><br><span class="line">             Iterator, Iterator)</span><br><span class="line">     : <span class="comment">// ...</span></span><br><span class="line">       <span class="built_in">createObj</span>(objFunc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClassDef</span>(ClassDef <span class="type">const</span> *, string &amp; <span class="type">const</span> name_,</span><br><span class="line">             CreateObjFunc objFunc)</span><br><span class="line">     : <span class="comment">// ...</span></span><br><span class="line">       <span class="built_in">createObj</span>(objFunc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object * <span class="title">newObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        definitionFix = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (*createObj)(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> CreateObjFunc createObj;</span><br><span class="line">    <span class="comment">// ... as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>And a simple change to <code>makeClass</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CppClass&gt;</span><br><span class="line"><span class="function">ClassDef <span class="title">makeClass</span><span class="params">(ClassDef <span class="type">const</span> * base, string <span class="type">const</span> &amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ClassDef</span>(base, name,</span><br><span class="line">                    CppObject&lt;CppClass&gt;::newObject,</span><br><span class="line">                    CppClass::<span class="built_in">ownAttribBegin</span>(),</span><br><span class="line">                    CppClass::<span class="built_in">ownAttribEnd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now, everything works. Well – nearly. If we now try to create a <code>ClassDef</code> for <code>Product</code> with <code>makeClass</code> the compiler complains about creating an abstract class: <code>makeClass</code> gives the <code>ClassDef</code> constructor a pointer to <code>CppObject::newObject()</code>, and that creates a <code>Product</code> instance as part of <code>CppObject</code>. This is easily fixed: just call the <code>ClassDef</code> constructor directly with a null-pointer for the creation function, thus prohibiting the creation of a Product instance through the MOP.</p>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>The MOP, as you have it now, allows you to define the C++ classes as MOP classes as before:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassDef <span class="title">base</span><span class="params">(<span class="number">0</span>, <span class="string">&quot;Product&quot;</span>, <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              Product::ownAttribBegin(),</span></span></span><br><span class="line"><span class="params"><span class="function">              Product::ownAttribEnd())</span></span>;</span><br><span class="line"><span class="function">ClassDef <span class="title">book</span><span class="params">(makeClass&lt;Book&gt;(&amp;base, <span class="string">&quot;Book&quot;</span>))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>You can create instances of them<br><code>book.newObject();</code><br>You can define new classes derived from <code>Product</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassDef * tShirt</span><br><span class="line">    = <span class="keyword">new</span> <span class="built_in">ClassDef</span>(&amp;base, <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">          DynaObject::newObject);</span><br><span class="line"></span><br><span class="line">tShirt-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Size&quot;</span>, Type::stringT));</span><br><span class="line">tShirt-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Color&quot;</span>, Type::stringT));</span><br><span class="line">tShirt-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Name&quot;</span>, Type::stringT));</span><br><span class="line">tShirt-&gt;<span class="built_in">addAttribute</span>(<span class="built_in">Attribute</span>(<span class="string">&quot;Price&quot;</span>, Type::doubleT));</span><br><span class="line"></span><br><span class="line">classReg.<span class="built_in">registerClass</span>(tShirt);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>and manipulate instances of existing classes and new classes through the MOP:<br>A C++ object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object * <span class="title">ecpp</span><span class="params">(book.newObject())</span></span>;</span><br><span class="line"></span><br><span class="line">ecpp-&gt;<span class="built_in">setValue</span>(<span class="number">5</span>, <span class="built_in">RealValue</span>&lt;<span class="type">double</span>&gt;(<span class="number">22.50</span>));</span><br><span class="line">ecpp-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>, <span class="built_in">RealValue</span>&lt;<span class="type">int</span>&gt;(<span class="number">23456</span>));</span><br><span class="line">ecpp-&gt;<span class="built_in">setValue</span>(<span class="number">2</span>, <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;Scott Meyers&quot;</span>));</span><br><span class="line">ecpp-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Title&quot;</span>, <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;Effective C++&quot;</span>));</span><br><span class="line">ecpp-&gt;<span class="built_in">setValue</span>(<span class="number">6</span>, <span class="built_in">RealValue</span>&lt;<span class="type">double</span>&gt;(<span class="number">280</span>));</span><br><span class="line"><span class="type">size_t</span> idx;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ecpp:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (a = book.<span class="built_in">attribBegin</span>(), idx = <span class="number">0</span>;</span><br><span class="line">     a != book.<span class="built_in">attribEnd</span>();</span><br><span class="line">     ++a, ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">         &lt;&lt; ecpp-&gt;<span class="built_in">getValue</span>(idx).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ecpp-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Author&quot;</span>).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>And a dynamic object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object * <span class="title">ts</span><span class="params">(tShirt.newObject())</span></span>;</span><br><span class="line">ts-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>, <span class="built_in">RealValue</span>&lt;<span class="type">int</span>&gt;(<span class="number">87654</span>));</span><br><span class="line">ts-&gt;<span class="built_in">setValue</span>(<span class="number">2</span>, <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;XXL&quot;</span>));</span><br><span class="line">ts-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Color&quot;</span>, <span class="built_in">RealValue</span>&lt;string&gt;(<span class="string">&quot;red&quot;</span>));</span><br><span class="line">ts-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Price&quot;</span>, <span class="built_in">RealValue</span>&lt;<span class="type">double</span>&gt;(<span class="number">25.95</span>));</span><br><span class="line">ts-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;Weight&quot;</span>, <span class="built_in">RealValue</span>&lt;<span class="type">double</span>&gt;(<span class="number">387</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> idx = <span class="number">0</span>; idx != <span class="number">4</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ts-&gt;<span class="built_in">getValue</span>(idx).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C-Interface"><a href="#C-Interface" class="headerlink" title="C++ Interface"></a>C++ Interface</h3><p>You can’t access the instances created by the MOP through the <code>Product</code> interface. For instances of C++ classes you can modify the <code>CppObject</code> to derive from <code>T</code> as we have discussed before, or better, to provide a member function in <code>CppObject</code> that returns a pointer to <code>myObject</code>. And for instances of MOP classes you can define a wrapper around an <code>Object</code> that implements the <code>Product</code> interface:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynaProduct</span> : <span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynaProduct</span>(Object <span class="type">const</span> * o) : <span class="built_in">obj</span>(o) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;std::string&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Price&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getWeight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Value v = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;Weight&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Object <span class="type">const</span> * <span class="type">const</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>And you can’t access normal C++ instances of <code>Book</code> through the MOP; to solve this, you could add another constructor that adopts the C++ instance by copying (and consequently you should delete the original one to avoid an object that exists twice) or you could modify the wrapper to hold only a pointer to the C++ object and add a member function to return the controlled C++ object on request: Here, we use the first approach:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OrigClass&gt;</span><br><span class="line">CppObject&lt;OrigClass&gt;::<span class="built_in">CppObject</span>(ClassDef <span class="type">const</span> * myClass,</span><br><span class="line">                                OrigClass <span class="type">const</span> &amp; obj)</span><br><span class="line"> : <span class="built_in">Object</span>(myClass),</span><br><span class="line">   <span class="built_in">myObject</span>(obj), <span class="comment">// calls the copy-ctor of OrigClass,</span></span><br><span class="line">                     <span class="function">which must be accessible</span></span><br><span class="line"><span class="function">   <span class="title">members</span><span class="params">(OrigClass::memberBegin())</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>And now, you can do this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Book <span class="title">b</span><span class="params">(<span class="string">&quot;Bjarne Stroustrup&quot;</span>, <span class="string">&quot;The C++ Programming Language&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="string">&quot;Addison-Wesley&quot;</span>, <span class="number">27.50</span>, <span class="number">370</span>)</span></span>;</span><br><span class="line"><span class="function">CppObject&lt;Book&gt; <span class="title">mb</span><span class="params">(*book, b)</span></span>;</span><br><span class="line">Object * ob = &amp;mb;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++ object through MOP&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (a = ob-&gt;<span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribBegin</span>(), idx = <span class="number">0</span>;</span><br><span class="line">     a != ob-&gt;<span class="built_in">instanceOf</span>()-&gt;<span class="built_in">attribEnd</span>();</span><br><span class="line">     ++a, ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">         &lt;&lt; ob-&gt;<span class="built_in">getValue</span>(idx).<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>But in general, it’s just important that you can define basic classes in C++ at programming time but allow the user to derive own classes from these base classes at runtime.</p>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><p>Is such a MOP approach for C++ actually useful? The pure reflection mechanism based on pointers-to-members is quite useful for persistence libraries – on relational databases or file formats like XML. This was the application when I first used pointers-to-members in C++, which were just the C++ replacement of the old C <code>offsetOf</code> macro that is still in widespread use for that purpose.<br>But I also came across quite a lot of applications where a handful of pre-defined entities provided 98% of the requirements of the users of the system, but the remaining 2% were so different for different users that a common solution for all was not adequate. For these special cases, a full meta-object protocol approach was really a quite simple and elegant solution that provided all the flexibility the users requested.</p>
<h2 id="Two-final-remarks"><a href="#Two-final-remarks" class="headerlink" title="Two final remarks"></a>Two final remarks</h2><p>Could the same kind of reflection be achieved with <code>get</code>/<code>set</code> functions instead of pointers-to-members? Perhaps, yes. Some component mechanisms use that approach (e.g. Borland’s VCL). In that case, a <code>get()</code> and <code>set()</code> function for each attribute and a specialized <code>TypedMemPtr&lt;&gt;</code> for each attribute for each class is required. That’s a lot of work, but with a respective pre-processor or compiler support that’s not a point. But it’s still much more intrusive to add all the getters and setters; and if they are public, they break encapsulation. Though pointers-to-members allow direct access to the data, that encapsulation leak can be much better controlled.</p>
<p>The second remark relates to <code>RealValue&lt;&gt;</code>. Are they really necessary for true reflection purpose? Actually not. In that case, you could remove <code>BaseTargetType</code> from all <code>MemPtr</code> templates, return the <code>TargetType</code> in <code>TypedMemPtr</code>‘s getter function, and make the getter function of the <code>MemPtr</code> handle a member template function analogous to the getter function of <code>Value</code>. In the source code for this article (<a target="_blank" rel="noopener" href="http://www.vollmann.com/download/mop/index.html"> http://www.vollmann.com/download/mop/index.html</a>) you’ll find a sample implementation for that.<br>Though this seems to be a major advantage for pure reflection applications like persistency libraries, in fact I found it in most cases quite useful to have a base class like <code>DbValue</code> for all persistent attributes to provide additional functionality like dirty flags, type conversion specifics, etc.</p>
<h2 id="Coming-articles"><a href="#Coming-articles" class="headerlink" title="Coming articles"></a>Coming articles</h2><p>This article provided reflection and meta-class facilities for data attributes only. A following article will show the application of a MOP for the integration of a scripting language. And that will then allow to extend the MOP with member functions as well.<br>Another article will look into the capabilities of preprocessors to provide the reflection information.<br>And yet another article will look at real applications for reflection and meta-classes, like DB libraries.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bkverweis1">1</a>] Gregor Kiczales, Jim des Rivières, Daniel G. Bobrow: “The Art of the Metaobject Protocol”, MIT Press 1991, ISBN 0-262-61074-4</p>
<p>[<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bkverweis2">2</a>] James O. Coplien: “Advanced C++ Programming Styles And Idioms”, Chapters 8-10, Addison-Wesley, 1992, ISBN 0-201-54855-0</p>
<p>[<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bkverweis3">3</a>] Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, Michael Stal: “Pattern-Oriented Software Architecture: A System of Patterns”, Wiley 1996, ISBN 0-471-95869-7</p>
<p>[<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bkverweis4">4</a>] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides: “Design Patterns”, Addison-Wesley 1994, ISBN 0-201-63361-2</p>
<p>[<a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#bkverweis5">5</a>] Michael S. Ball, Stephen D. Clamage: “Pointers-to-Members”, C++ Report 11(10):8-12, Nov/Dec 1999</p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis1">1</a> I will not elaborate on differences between type and class.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis2">2</a> The idea of the search machine is to have a batch process that queries all objects about its attribute values and create an own internal index from that information.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis3">3</a> actually, a simple array would suffice, as its size is fix and known at compile time. But for future extensions a vector is more flexible.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis4">4</a> As <code>class</code> is a reserved word in C++, and I don’t like identifiers to differ only in case from others I have chosen <code>ClassDef</code> here.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis5">5</a> <code>fromString()</code> would also be useful, but we omit it here.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis6">6</a> In fact, a pointer-to-member is not as easy as an offset. Especially if multiple inheritance comes in, things become more complicated.<br><a target="_blank" rel="noopener" href="http://www.vollmann.com/en/pubs/meta/meta/meta.html#fnverweis7">7</a> It might be necessary to adjust that offset, but the compiler cares for that.</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Jok Brown
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.likepanda.cn/2023/03/29/reflection/" title="reflection">http://www.likepanda.cn/2023/03/29/reflection/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/15/datastructure/" rel="next" title="datastructure">
                  datastructure <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jok Brown</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>



  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
